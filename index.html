<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proportional Golden Controller</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000; /* Pitch Black */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .input_video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            z-index: 2;
            transform: scaleX(-1);
            opacity: 0.5;
        }

        #status {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-size: 22px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 3px;
            z-index: 10;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 30px;
            border-radius: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 28px;
            z-index: 20;
            font-family: monospace;
            text-shadow: 0 0 20px #ffd700;
            animation: pulse 0.8s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; transform: translate(-50%, -50%) scale(0.95); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing Analog System...</div>
    <div id="status">Flex Hand to Control</div>
    
    <video class="input_video"></video>
    <div id="canvas-container"></div>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 5500;
        const PARTICLE_SIZE = 0.35;
        const SPHERE_RADIUS = 4.0;
        const RING_INNER_RADIUS = 6.0;
        const RING_OUTER_RADIUS = 11;
        const SCATTER_RADIUS = 40; // Max scatter distance
        
        // --- COLORS ---
        const COLOR_GOLD_BRIGHT = new THREE.Color(0xffd700); 
        const COLOR_GOLD_DEEP = new THREE.Color(0xffaa00);
        
        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.005); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Fixed Camera Position (Same as before: Straight & Centered)
        camera.position.set(0, 4, 22);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- PARTICLE DATA STRUCTURES ---
        const geometry = new THREE.BufferGeometry();
        
        // We need 3 Arrays:
        // 1. Current Positions (Rendered)
        // 2. Saturn Positions (Shape A)
        // 3. Scatter Positions (Shape B)
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const saturnPositions = new Float32Array(PARTICLE_COUNT * 3);
        const scatterPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        
        // --- INITIALIZE SHAPES ---
        // Pre-calculate both shapes so we can blend between them instantly
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            // --- 1. GENERATE SATURN (Shape A) ---
            let tx, ty, tz;
            let col;

            if (Math.random() > 0.4) {
                // SPHERE PART
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                
                tx = SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta);
                ty = SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta);
                tz = SPHERE_RADIUS * Math.cos(phi);
                col = COLOR_GOLD_DEEP;
            } else {
                // RING PART (Flat/Straight)
                const angle = Math.random() * Math.PI * 2;
                const radius = RING_INNER_RADIUS + Math.random() * (RING_OUTER_RADIUS - RING_INNER_RADIUS);
                
                tx = Math.cos(angle) * radius;
                ty = (Math.random() - 0.5) * 0.4; // Flat ring
                tz = Math.sin(angle) * radius;
                col = COLOR_GOLD_BRIGHT;
            }

            saturnPositions[i3] = tx;
            saturnPositions[i3 + 1] = ty;
            saturnPositions[i3 + 2] = tz;
            
            // Set Color based on Saturn shape (Always Gold)
            colors[i3] = col.r;
            colors[i3+1] = col.g;
            colors[i3+2] = col.b;

            // --- 2. GENERATE SCATTER (Shape B) ---
            // Random explosion outwards
            const r = Math.random() * SCATTER_RADIUS + 5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);

            scatterPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
            scatterPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            scatterPositions[i3 + 2] = r * Math.cos(phi);

            // Start positions at Scatter (Assuming hand starts open)
            positions[i3] = scatterPositions[i3];
            positions[i3 + 1] = scatterPositions[i3 + 1];
            positions[i3 + 2] = scatterPositions[i3 + 2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const textureLoader = new THREE.TextureLoader();
        const sprite = textureLoader.load('https://threejs.org/examples/textures/sprites/spark1.png');

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            map: sprite,
            vertexColors: true,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- INTERACTION VARIABLES ---
        let handOpenFactor = 1.0; // 0.0 = Fist (Saturn), 1.0 = Open (Scatter)
        let targetRotY = 0; // Spin Control

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            // Spin Logic
            particles.rotation.y += (targetRotY - particles.rotation.y) * 0.1;
            particles.rotation.x = 0; // No Tilt
            particles.rotation.z = 0;

            const positionAttribute = geometry.attributes.position;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                // --- KEY LOGIC: BLENDING ---
                // We calculate a "Mixed Target" based on handOpenFactor
                // Formula: Target = Saturn * (1 - factor) + Scatter * (factor)
                
                const mixedTx = saturnPositions[i3] * (1 - handOpenFactor) + scatterPositions[i3] * handOpenFactor;
                const mixedTy = saturnPositions[i3+1] * (1 - handOpenFactor) + scatterPositions[i3+1] * handOpenFactor;
                const mixedTz = saturnPositions[i3+2] * (1 - handOpenFactor) + scatterPositions[i3+2] * handOpenFactor;

                // Move current position towards the Mixed Target smoothly
                // 0.1 is the speed of reaction
                positions[i3]     += (mixedTx - positions[i3]) * 0.1;
                positions[i3 + 1] += (mixedTy - positions[i3 + 1]) * 0.1;
                positions[i3 + 2] += (mixedTz - positions[i3 + 2]) * 0.1;

                // Add subtle life/breathing effect
                // If mostly Saturn (factor close to 0), shimmer slightly
                if (handOpenFactor < 0.2) {
                    if (Math.random() > 0.99) {
                         positions[i3] += (Math.random() - 0.5) * 0.1;
                    }
                } 
                // If scattered, float slowly
                else {
                    positions[i3+1] += Math.sin(time + positions[i3]) * 0.01;
                }
            }
            positionAttribute.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();

        // --- HAND TRACKING ---
        const videoElement = document.querySelector('.input_video');
        const statusEl = document.getElementById('status');
        
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];

                // --- 1. SPIN CONTROL ---
                targetRotY = (wrist.x - 0.5) * 5; 

                // --- 2. OPENNESS DETECTION (ANALOG) ---
                const tips = [8, 12, 16, 20];
                let avgDist = 0;
                tips.forEach(tipIndex => {
                    const tip = landmarks[tipIndex];
                    // Distance from wrist
                    const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    avgDist += d;
                });
                avgDist = avgDist / tips.length;

                // Calibration:
                // Fist is usually around 0.15 - 0.20
                // Open Hand is usually > 0.40
                
                const minVal = 0.15; // Tight Fist
                const maxVal = 0.45; // Fully Open
                
                // Map avgDist to 0.0 - 1.0 range
                let rawFactor = (avgDist - minVal) / (maxVal - minVal);
                
                // Clamp values between 0 and 1
                if (rawFactor < 0) rawFactor = 0;
                if (rawFactor > 1) rawFactor = 1;

                // Set global factor for animation loop
                handOpenFactor = rawFactor;

                // --- STATUS TEXT UPDATE ---
                if (handOpenFactor < 0.1) {
                    statusEl.innerText = "LOCKED (0%)";
                    statusEl.style.textShadow = "0 0 20px #ffd700";
                    statusEl.style.color = "#fff";
                } else if (handOpenFactor > 0.9) {
                    statusEl.innerText = "SCATTERED (100%)";
                    statusEl.style.textShadow = "none";
                    statusEl.style.color = "#aaa";
                } else {
                    // Show percentage
                    const percent = Math.round(handOpenFactor * 100);
                    statusEl.innerText = `EXPANDING: ${percent}%`;
                    statusEl.style.textShadow = `0 0 ${20 * (1-handOpenFactor)}px #ffd700`;
                    statusEl.style.color = "#ffd700";
                }

            } else {
                // If hand lost, slowly drift to scatter
                handOpenFactor = handOpenFactor * 0.95 + 1.0 * 0.05; 
                targetRotY = 0;
                statusEl.innerText = "WAVE HAND";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraUtils.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

