<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Particle Saturn</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* Deep space black */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Small video preview to see yourself (optional, helpful for debugging) */
        .input_video {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 2;
            transform: scaleX(-1); /* Mirror effect */
            opacity: 0.5;
            transition: opacity 0.3s;
        }
        .input_video:hover {
            opacity: 1;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: 300;
            text-transform: uppercase;
            letter-spacing: 4px;
            z-index: 10;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 20px;
            z-index: 20;
            font-family: monospace;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing Neural Hand Tracking...</div>
    <div id="status">Waiting for Hand...</div>
    
    <!-- Video element for MediaPipe (Hidden but active) -->
    <video class="input_video"></video>
    
    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 8000;
        const PARTICLE_SIZE = 0.08;
        const SPHERE_RADIUS = 3;
        const RING_INNER_RADIUS = 4.5;
        const RING_OUTER_RADIUS = 8;
        const SCATTER_RADIUS = 25;
        
        // Colors
        const COLOR_SPHERE = new THREE.Color(0x00ffff); // Cyan
        const COLOR_RING = new THREE.Color(0xff00ff);   // Magenta
        const COLOR_SCATTER = new THREE.Color(0xaaaaaa); // White/Grey

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        // Add some soft fog for depth
        scene.fog = new THREE.FogExp2(0x050505, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        camera.position.y = 2;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance optimization
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const targetColors = new Float32Array(PARTICLE_COUNT * 3);

        // Initialize particles randomly scattered
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const x = (Math.random() - 0.5) * 50;
            const y = (Math.random() - 0.5) * 50;
            const z = (Math.random() - 0.5) * 50;

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            // Start white
            colors[i * 3] = 1;
            colors[i * 3 + 1] = 1;
            colors[i * 3 + 2] = 1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Use a glowing texture for particles
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            map: sprite,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- SHAPE GENERATION FUNCTIONS ---

        // 1. Generate Target: Saturn (Sphere + Ring)
        function generateSaturnTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let tx, ty, tz;
                let r, g, b;

                // 70% of particles form the Sphere, 30% form the Ring
                if (Math.random() > 0.3) {
                    // SPHERE LOGIC
                    // Uniform point on sphere surface
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    
                    tx = SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta);
                    ty = SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta);
                    tz = SPHERE_RADIUS * Math.cos(phi);

                    r = COLOR_SPHERE.r;
                    g = COLOR_SPHERE.g;
                    b = COLOR_SPHERE.b;
                } else {
                    // RING LOGIC
                    const angle = Math.random() * Math.PI * 2;
                    // Distribute radius to make ring look solid
                    const radius = RING_INNER_RADIUS + Math.random() * (RING_OUTER_RADIUS - RING_INNER_RADIUS);
                    
                    tx = Math.cos(angle) * radius;
                    ty = (Math.random() - 0.5) * 0.2; // Very thin height
                    tz = Math.sin(angle) * radius;

                    // Tilt the ring slightly for 3D effect
                    const tiltAngle = Math.PI / 6; // 30 degrees
                    const yTemp = ty * Math.cos(tiltAngle) - tz * Math.sin(tiltAngle);
                    const zTemp = ty * Math.sin(tiltAngle) + tz * Math.cos(tiltAngle);
                    ty = yTemp;
                    tz = zTemp;

                    r = COLOR_RING.r;
                    g = COLOR_RING.g;
                    b = COLOR_RING.b;
                }

                targetPositions[i3] = tx;
                targetPositions[i3 + 1] = ty;
                targetPositions[i3 + 2] = tz;
                
                targetColors[i3] = r;
                targetColors[i3 + 1] = g;
                targetColors[i3 + 2] = b;
            }
        }

        // 2. Generate Target: Scattered (Open Hand)
        function generateScatterTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // Random drift vector
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = Math.random() * SCATTER_RADIUS + 5; // Minimum distance 5

                targetPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                targetPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                targetPositions[i3 + 2] = r * Math.cos(phi);

                // Pale colors for scattered state
                targetColors[i3] = COLOR_SCATTER.r;
                targetColors[i3 + 1] = COLOR_SCATTER.g;
                targetColors[i3 + 2] = COLOR_SCATTER.b;
            }
        }

        // --- STATE MANAGEMENT ---
        let currentState = 'SCATTER'; // 'SATURN' or 'SCATTER'
        
        // Initial State
        generateScatterTargets();

        function setShape(shape) {
            if (currentState === shape) return;
            currentState = shape;

            if (shape === 'SATURN') {
                document.getElementById('status').innerText = "FIST DETECTED: FORMING PLANET";
                document.getElementById('status').style.color = "#00ffff";
                generateSaturnTargets();
            } else {
                document.getElementById('status').innerText = "HAND OPEN: SCATTERING";
                document.getElementById('status').style.color = "#ffffff";
                generateScatterTargets();
            }
        }

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += clock.getDelta();

            const positionAttribute = geometry.attributes.position;
            const colorAttribute = geometry.attributes.color;

            // Lerp speed: How fast particles move to target (0.05 is slow/smooth, 0.1 is snappy)
            const lerpFactor = 0.08;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                // 1. Move Position smoothly towards target
                positions[i3]     += (targetPositions[i3] - positions[i3]) * lerpFactor;
                positions[i3 + 1] += (targetPositions[i3 + 1] - positions[i3 + 1]) * lerpFactor;
                positions[i3 + 2] += (targetPositions[i3 + 2] - positions[i3 + 2]) * lerpFactor;

                // 2. Add some "life" (noise/wobble) so they aren't perfectly static
                if (currentState === 'SATURN') {
                    // Spin the ring
                    if (i % 2 === 0) { // Simple check to identify ring vs sphere roughly (randomized earlier but this adds noise everywhere)
                         // A subtle orbit rotation could be added here mathematically, 
                         // but for simplicity we add a tiny jitter
                         positions[i3] += (Math.random() - 0.5) * 0.02;
                         positions[i3+1] += (Math.random() - 0.5) * 0.02;
                         positions[i3+2] += (Math.random() - 0.5) * 0.02;
                    }
                } else {
                    // Drifting effect when scattered
                    positions[i3] += Math.sin(time + i) * 0.01;
                    positions[i3+1] += Math.cos(time + i * 0.5) * 0.01;
                }

                // 3. Morph Color
                colors[i3]     += (targetColors[i3] - colors[i3]) * 0.05;
                colors[i3 + 1] += (targetColors[i3 + 1] - colors[i3 + 1]) * 0.05;
                colors[i3 + 2] += (targetColors[i3 + 2] - colors[i3 + 2]) * 0.05;
            }

            positionAttribute.needsUpdate = true;
            colorAttribute.needsUpdate = true;

            // Rotate the entire system slowly
            particles.rotation.y += 0.002;
            if (currentState === 'SATURN') {
                particles.rotation.z = Math.sin(time * 0.5) * 0.1; // Gentle bobbing
            }

            renderer.render(scene, camera);
        }

        animate();

        // --- MEDIAPIPE HAND TRACKING ---
        const videoElement = document.querySelector('.input_video');
        
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // DETECT GESTURE
                // We calculate the average distance of finger tips to the wrist (landmark 0)
                
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky tips
                
                let avgDist = 0;
                
                tips.forEach(tipIndex => {
                    const tip = landmarks[tipIndex];
                    // Simple Euclidean distance (ignoring Z for simplicity, or include it)
                    const dx = tip.x - wrist.x;
                    const dy = tip.y - wrist.y;
                    const dz = tip.z - wrist.z; // Z is depth relative to wrist
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    avgDist += dist;
                });
                
                avgDist = avgDist / tips.length;

                // Threshold: Experimentally, < 0.2 is usually a fist, > 0.3 is open
                // console.log("Hand Openness:", avgDist); // Uncomment to debug

                if (avgDist < 0.25) {
                    setShape('SATURN');
                } else {
                    setShape('SCATTER');
                }

            } else {
                // No hands detected? default to scatter
                // setShape('SCATTER'); 
                document.getElementById('status').innerText = "SHOW YOUR HAND";
                document.getElementById('status').style.color = "#aaaaaa";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraUtils.start();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

