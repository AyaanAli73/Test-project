<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Particle Sphere</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Mirror the video so interaction feels natural */
        #input-video { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 160px; 
            height: 120px; 
            z-index: 10; 
            border-radius: 8px; 
            border: 2px solid rgba(255,255,255,0.2);
            transform: scaleX(-1); 
            display: none; /* Hidden until loaded */
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 20;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            z-index: 5;
            pointer-events: none;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px auto;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div id="hud">
        <h1 class="text-2xl font-bold tracking-wider mb-2">NEURO SPHERE</h1>
        <div class="text-sm space-y-1 opacity-75">
            <p><span class="text-cyan-400 font-bold">OPEN HAND:</span> Move & Rotate</p>
            <p><span class="text-red-400 font-bold">FIST:</span> Charge Implosion</p>
            <p><span class="text-yellow-400 font-bold">RELEASE FIST:</span> Explode</p>
        </div>
        <div id="status-text" class="mt-4 text-xs font-mono text-green-400">System: Waiting for camera...</div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Initializing AI Vision...</div>
    </div>

    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 12000;
        const SPHERE_RADIUS = 30;
        const EXPLOSION_FORCE = 3.5;
        const RETURN_SPEED = 0.04;
        
        // --- STATE MANAGEMENT ---
        const state = {
            handDetected: false,
            handPosition: new THREE.Vector3(0, 0, 0), // Normalized -1 to 1
            isFist: false,
            wasFist: false, // For detecting the "release" moment
            mode: 'IDLE', // IDLE, CHARGING, EXPLODING, RETURNING
            explosionTimer: 0
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const initialPositions = [];
        const currentPositions = [];
        const velocities = [];
        const colors = [];

        const colorObj = new THREE.Color();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Create a sphere distribution
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;

            const x = SPHERE_RADIUS * Math.cos(theta) * Math.sin(phi);
            const y = SPHERE_RADIUS * Math.sin(theta) * Math.sin(phi);
            const z = SPHERE_RADIUS * Math.cos(phi);

            initialPositions.push(x, y, z);
            currentPositions.push(x, y, z); // Start at home
            
            // Random explosion velocity direction (normalized from center)
            const v = new THREE.Vector3(x, y, z).normalize().multiplyScalar(Math.random() * 0.5);
            velocities.push(v.x, v.y, v.z);

            // Color gradient based on position
            colorObj.setHSL((y / SPHERE_RADIUS + 1) / 2 * 0.2 + 0.5, 0.8, 0.6);
            colors.push(colorObj.r, colorObj.g, colorObj.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(currentPositions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        // Custom attributes for animation logic
        geometry.userData = {
            initialPositions: new Float32Array(initialPositions),
            velocities: new Float32Array(velocities)
        };

        const material = new THREE.PointsMaterial({
            size: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Add some ambient light helpers (visual flair only, particles emit own light)
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // --- MEDIAPIPE LOGIC ---
        const videoElement = document.getElementById('input-video');
        const statusText = document.getElementById('status-text');
        const loadingDiv = document.getElementById('loading');

        function onResults(results) {
            loadingDiv.style.display = 'none';
            videoElement.style.display = 'block';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                statusText.innerText = "System: Hand Tracking Active";
                
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Calculate Hand Position (Index finger base - landmark 5)
                // Remap from 0..1 to -1..1 range for Three.js scene
                // X is inverted because of the mirror effect
                const x = (1 - landmarks[9].x) * 2 - 1; 
                const y = -(landmarks[9].y * 2 - 1); 
                
                // Smooth interpolation for hand position
                state.handPosition.lerp(new THREE.Vector3(x * 60, y * 40, 0), 0.2);

                // 2. Gesture Detection (Fist vs Open)
                // Compare wrist (0) to finger tips (8, 12, 16, 20)
                const wrist = landmarks[0];
                const tips = [landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
                
                let avgDist = 0;
                tips.forEach(tip => {
                    const d = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                    avgDist += d;
                });
                avgDist /= 4;

                // Thresholds usually around 0.2 for fist, 0.4+ for open
                const isFistNow = avgDist < 0.25;

                state.wasFist = state.isFist;
                state.isFist = isFistNow;

                handleStateTransitions();

            } else {
                state.handDetected = false;
                statusText.innerText = "System: No Hand Detected";
            }
        }

        function handleStateTransitions() {
            // Trigger Explosion: Was Fist -> Now Open
            if (state.wasFist && !state.isFist && state.mode !== 'EXPLODING') {
                triggerExplosion();
            }

            // Trigger Charging: Is Fist
            if (state.isFist) {
                state.mode = 'CHARGING';
            } else if (state.mode === 'CHARGING' && !state.isFist) {
                // If we were charging but just opened (handled by explosion trigger usually, 
                // but if we need a fallback for gentle release)
            }
        }

        function triggerExplosion() {
            state.mode = 'EXPLODING';
            state.explosionTimer = Date.now();
            statusText.innerText = "System: EXPLOSION TRIGGERED";
            
            // Randomize velocity directions slightly for chaos
            const vels = particles.geometry.userData.velocities;
            for(let i=0; i < vels.length; i+=3) {
                vels[i] *= (0.8 + Math.random() * 0.4);
                vels[i+1] *= (0.8 + Math.random() * 0.4);
                vels[i+2] *= (0.8 + Math.random() * 0.4);
            }
        }

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;
            const positions = particles.geometry.attributes.position.array;
            const initialPos = particles.geometry.userData.initialPositions;
            const vels = particles.geometry.userData.velocities;

            // Logic Switch based on Mode
            if (state.mode === 'EXPLODING') {
                // Check timer to return
                if (Date.now() - state.explosionTimer > 2000) {
                    state.mode = 'RETURNING';
                    statusText.innerText = "System: Reforming Structure";
                }

                // Apply Explosion Physics
                for (let i = 0; i < positions.length; i += 3) {
                    // Move outwards based on stored velocity * force
                    positions[i] += vels[i] * EXPLOSION_FORCE;
                    positions[i+1] += vels[i+1] * EXPLOSION_FORCE;
                    positions[i+2] += vels[i+2] * EXPLOSION_FORCE;
                }

                // Add some camera shake
                camera.position.x = (Math.random() - 0.5) * 1;
                camera.position.y = (Math.random() - 0.5) * 1;

            } 
            else if (state.mode === 'RETURNING') {
                let totalDist = 0;
                
                // Lerp back to original sphere shape
                // But if hand is present, rotate the entire sphere container (handled later)
                // Here we just reform the shape relative to local origin
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += (initialPos[i] - positions[i]) * RETURN_SPEED;
                    positions[i+1] += (initialPos[i+1] - positions[i+1]) * RETURN_SPEED;
                    positions[i+2] += (initialPos[i+2] - positions[i+2]) * RETURN_SPEED;
                    
                    const d = Math.abs(initialPos[i] - positions[i]);
                    totalDist += d;
                }

                // If mostly reformed, go to IDLE
                if (totalDist / PARTICLE_COUNT < 0.5) {
                    state.mode = 'IDLE';
                    camera.position.set(0, 0, 100); // Reset cam
                }
            } 
            else if (state.mode === 'CHARGING') {
                // Implosion / Fist effect
                // Move particles towards the Hand Position (or center if no hand)
                const targetX = state.handDetected ? state.handPosition.x : 0;
                const targetY = state.handDetected ? state.handPosition.y : 0;
                const targetZ = state.handDetected ? state.handPosition.z : 0;

                for (let i = 0; i < positions.length; i += 3) {
                    // Strong attraction to center
                    positions[i] += (targetX - positions[i]) * 0.1;
                    positions[i+1] += (targetY - positions[i+1]) * 0.1;
                    positions[i+2] += (targetZ - positions[i+2]) * 0.1;

                    // Add Jitter/Vibration
                    positions[i] += (Math.random() - 0.5) * 1.5;
                    positions[i+1] += (Math.random() - 0.5) * 1.5;
                    positions[i+2] += (Math.random() - 0.5) * 1.5;
                }
            } 
            else if (state.mode === 'IDLE') {
                // Normal Rotation & Hover
                // If hand is detected and OPEN, follow hand
                if (state.handDetected) {
                    // Rotate the whole particle system based on hand X
                    particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, state.handPosition.x * 0.05, 0.1);
                    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, -state.handPosition.y * 0.05, 0.1);
                    
                    // Move the system slightly towards hand
                    particles.position.lerp(new THREE.Vector3(state.handPosition.x * 0.5, state.handPosition.y * 0.5, 0), 0.05);
                } else {
                    // Auto idle rotation
                    particles.rotation.y += 0.002;
                    particles.position.lerp(new THREE.Vector3(0,0,0), 0.05);
                }

                // Breathing effect on individual particles
                for (let i = 0; i < positions.length; i += 3) {
                    // Reset to sphere shape slowly if drifting
                    positions[i] += (initialPos[i] - positions[i]) * 0.1;
                    positions[i+1] += (initialPos[i+1] - positions[i+1]) * 0.1;
                    positions[i+2] += (initialPos[i+2] - positions[i+2]) * 0.1;
                    
                    // Noise movement
                    positions[i] += Math.sin(time + positions[i+1]) * 0.05;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- INIT MEDIA PIPE ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraFeed.start()
            .then(() => {
                console.log("Camera started");
                animate();
            })
            .catch(err => {
                console.error(err);
                document.getElementById('loading-text').innerText = "Error accessing camera. Please allow permissions.";
            });

    </script>
</body>
</html>

