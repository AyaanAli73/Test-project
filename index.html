<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galactic Hand Force</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js for GPU Acceleration -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    
    <!-- MediaPipe Vision -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        
        #videoElement { 
            display: none; 
            transform: scaleX(-1); 
        }

        .hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        .status-badge {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 999px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #00ffcc;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
            transition: all 0.3s ease;
        }

        .cam-preview {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            background: #000;
            opacity: 0.5;
            z-index: 5;
            overflow: hidden;
        }
        .cam-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* Loading Animation */
        #loader {
            position: fixed;
            inset: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="text-white text-2xl font-bold tracking-[0.2em] mb-4">INITIALIZING CORE</div>
        <div class="w-48 h-1 bg-gray-800 rounded-full overflow-hidden">
            <div id="loaderBar" class="h-full bg-cyan-500 w-0 transition-all duration-[2000ms]"></div>
        </div>
        <p class="text-gray-500 text-xs mt-4">Allow camera to begin</p>
    </div>

    <!-- Hidden Video Source -->
    <video id="videoElement" playsinline></video>
    
    <!-- Small PIP -->
    <div class="cam-preview">
        <video id="previewVideo" playsinline muted autoplay></video>
    </div>

    <div class="hud">
        <div id="status" class="status-badge">
            <span class="w-2 h-2 rounded-full bg-red-500 animate-pulse" id="statusDot"></span>
            <span id="statusText">WAITING FOR HAND</span>
        </div>
        <div class="text-gray-500 text-[10px] mt-2 tracking-wider">PINCH TO CHARGE â€¢ RELEASE TO EXPLODE</div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const PARTICLE_COUNT = 15000; // High count for GPU
        const CAMERA_Z = 1000;
        
        // --- State ---
        const state = {
            handActive: false,
            handX: 0, 
            handY: 0,
            isPinching: false,
            wasPinching: false,
            chargeLevel: 0, // 0 to 1
        };

        // --- Elements ---
        const videoElement = document.getElementById('videoElement');
        const previewVideo = document.getElementById('previewVideo');
        const statusText = document.getElementById('statusText');
        const statusDot = document.getElementById('statusDot');
        const statusBadge = document.getElementById('status');
        const loader = document.getElementById('loader');
        const loaderBar = document.getElementById('loaderBar');

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        // Cinematic fog to hide edges
        scene.fog = new THREE.FogExp2(0x000000, 0.0008); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
        camera.position.z = CAMERA_Z;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- Particle System ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const velocities = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);

        const color1 = new THREE.Color(0x00ffff); // Cyan
        const color2 = new THREE.Color(0xff00ff); // Magenta
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Random spread
            positions[i * 3] = (Math.random() - 0.5) * 2000;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 1500;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 1000; // Depth

            velocities[i * 3] = (Math.random() - 0.5) * 2;
            velocities[i * 3 + 1] = (Math.random() - 0.5) * 2;
            velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;

            // Mix colors
            const mixedColor = color1.clone().lerp(color2, Math.random());
            colors[i * 3] = mixedColor.r;
            colors[i * 3 + 1] = mixedColor.g;
            colors[i * 3 + 2] = mixedColor.b;

            sizes[i] = Math.random() * 4;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Shader Material for Glowing Dots
        // Using a custom shader gives us better performance and visual control than PointsMaterial
        const material = new THREE.ShaderMaterial({
            uniforms: {
                pointTexture: { value: createCircleTexture() }
            },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (1000.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                    gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- Physics Engine (The Fun Part) ---
        function updateParticles() {
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;
            
            // Map hand coordinates to 3D world space approximately
            // Screen is -Width/2 to Width/2. 
            // At Z=0 (where particles effectively are), width is approx 2 * tan(fov/2) * dist
            const targetX = (state.handX - 0.5) * 2 * (window.innerWidth / 1.5);
            const targetY = -(state.handY - 0.5) * 2 * (window.innerHeight / 1.5); // Invert Y
            
            // Explosion Trigger
            let isExploding = false;
            if (state.wasPinching && !state.isPinching) {
                isExploding = true;
                // Shake camera effect
                camera.position.x = (Math.random() - 0.5) * 50;
                camera.position.y = (Math.random() - 0.5) * 50;
                setTimeout(() => { camera.position.x = 0; camera.position.y = 0; }, 200);
            }
            state.wasPinching = state.isPinching;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let px = positions[ix];
                let py = positions[iy];
                let pz = positions[iz];

                let vx = velocities[ix];
                let vy = velocities[iy];
                let vz = velocities[iz];

                if (state.handActive) {
                    const dx = targetX - px;
                    const dy = targetY - py;
                    const dz = 0 - pz; // Attract to Z plane 0
                    const distSq = dx*dx + dy*dy + dz*dz;
                    const dist = Math.sqrt(distSq);

                    if (isExploding) {
                        // EXPLOSION: Massive outward force from hand center
                        const force = 1000 / (dist + 10); // Stronger when closer
                        // Add randomness to make it look like sparks
                        velocities[ix] -= (dx / dist) * force * (2 + Math.random());
                        velocities[iy] -= (dy / dist) * force * (2 + Math.random());
                        velocities[iz] -= (dz / dist) * force * (2 + Math.random());
                        
                        // Flash White
                        colors[ix] = 1; colors[iy] = 1; colors[iz] = 1;

                    } else if (state.isPinching) {
                        // BLACK HOLE: Aggressive suction
                        // Velocity damping (friction) to stop them flying past
                        velocities[ix] *= 0.85;
                        velocities[iy] *= 0.85;
                        velocities[iz] *= 0.85;

                        // Pull force
                        const force = 20; 
                        velocities[ix] += (dx / dist) * force;
                        velocities[iy] += (dy / dist) * force;
                        velocities[iz] += (dz / dist) * force;

                        // Color turns Red/Orange as they heat up
                        colors[ix] = 1; 
                        colors[iy] = 0.2; 
                        colors[iz] = 0;

                    } else {
                        // ELECTRON VORTEX: Spin around hand
                        // Calculate tangent vector for rotation
                        // Cross product of Up Vector (0,0,1) and Direction to Hand
                        const crossX = -dy;
                        const crossY = dx;
                        
                        // Add rotational force
                        const rotSpeed = 20000 / (distSq + 1000); // Faster near center
                        velocities[ix] += (crossX / dist) * rotSpeed;
                        velocities[iy] += (crossY / dist) * rotSpeed;

                        // Slight attraction to keep them in orbit
                        velocities[ix] += (dx / dist) * 2;
                        velocities[iy] += (dy / dist) * 2;
                        velocities[iz] += (dz / dist) * 2;

                        // Damping
                        velocities[ix] *= 0.96;
                        velocities[iy] *= 0.96;
                        velocities[iz] *= 0.96;

                        // Reset Color to Blue/Cyan/Purple
                        if (colors[ix] > 0.5 && colors[iy] < 0.5) { // If red (from pinch)
                            colors[ix] *= 0.95; // Fade red
                            colors[iy] += 0.05; // Bring back green/blue
                            colors[iz] += 0.05;
                        }
                    }

                } else {
                    // IDLE: Gentle drift
                    velocities[ix] += (Math.random() - 0.5) * 0.2;
                    velocities[iy] += (Math.random() - 0.5) * 0.2;
                    velocities[iz] += (Math.random() - 0.5) * 0.2;
                    velocities[ix] *= 0.98;
                    velocities[iy] *= 0.98;
                    velocities[iz] *= 0.98;
                }

                // Apply Velocity
                positions[ix] += velocities[ix];
                positions[iy] += velocities[iy];
                positions[iz] += velocities[iz];

                // Bounds check (teleport if too far to keep scene populated)
                if (positions[ix] > 2000) positions[ix] -= 4000;
                if (positions[ix] < -2000) positions[ix] += 4000;
                if (positions[iy] > 1500) positions[iy] -= 3000;
                if (positions[iy] < -1500) positions[iy] += 3000;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
        }

        // --- Render Loop ---
        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            renderer.render(scene, camera);
        }
        animate();

        // --- Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        // --- MediaPipe Logic ---
        function onResults(results) {
            // Loader logic
            if (loader.style.opacity !== '0') {
                loaderBar.style.width = '100%';
                setTimeout(() => {
                    loader.style.opacity = '0';
                    setTimeout(() => loader.style.display = 'none', 500);
                }, 500);
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const index = landmarks[8];
                const thumb = landmarks[4];
                const wrist = landmarks[0];

                // Update Hand Position (Smooth lerp)
                // Note: MediaPipe x is normalized [0,1]. Flip X for mirror effect.
                const targetHandX = 1 - index.x;
                const targetHandY = index.y;

                state.handX = state.handX + (targetHandX - state.handX) * 0.3;
                state.handY = state.handY + (targetHandY - state.handY) * 0.3;
                state.handActive = true;

                // Pinch Detection
                const pinchDist = Math.hypot(index.x - thumb.x, index.y - thumb.y);
                state.isPinching = pinchDist < 0.05;

                // UI Update
                if (state.isPinching) {
                    statusText.textContent = "CHARGING SINGULARITY";
                    statusDot.className = "w-2 h-2 rounded-full bg-white animate-ping";
                    statusBadge.style.borderColor = "#ff0055";
                    statusBadge.style.color = "#ff0055";
                    statusBadge.style.boxShadow = "0 0 30px #ff0055";
                } else {
                    statusText.textContent = "VORTEX ACTIVE";
                    statusDot.className = "w-2 h-2 rounded-full bg-cyan-400";
                    statusBadge.style.borderColor = "rgba(0,255,204,0.5)";
                    statusBadge.style.color = "#00ffcc";
                    statusBadge.style.boxShadow = "0 0 20px rgba(0,255,204,0.2)";
                }

            } else {
                state.handActive = false;
                statusText.textContent = "SEARCHING FOR HAND";
                statusDot.className = "w-2 h-2 rounded-full bg-red-500 animate-pulse";
                statusBadge.style.borderColor = "rgba(255,255,255,0.2)";
                statusBadge.style.color = "#888";
                statusBadge.style.boxShadow = "none";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraModule = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // Link Preview
        videoElement.addEventListener('loadeddata', () => {
            if(videoElement.srcObject) previewVideo.srcObject = videoElement.srcObject;
        });

        cameraModule.start();

    </script>
</body>
</html>


