<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fast Gesture Control - Torus Knot</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        
        /* Mirror video for natural interaction */
        #input-video { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 120px; 
            height: 90px; 
            z-index: 10; 
            border-radius: 8px; 
            opacity: 0.6;
            transform: scaleX(-1); 
            display: none;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            pointer-events: none;
            font-family: 'Courier New', Courier, monospace;
        }

        .hud-text {
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc;
        }
        
        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffcc;
            font-family: sans-serif;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 1px solid #00ffcc;
            border-radius: 8px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1 class="text-2xl font-bold hud-text mb-1">CYBER KNOT</h1>
        <div class="text-xs text-white opacity-70">
            LATENCY: <span id="latency-val" class="text-green-400">OPTIMIZED</span><br>
            MODE: <span id="mode-val" class="text-yellow-400">IDLE</span>
        </div>
    </div>

    <div id="loader">
        <p class="animate-pulse">INITIALIZING NEURAL LINK...</p>
        <p class="text-xs text-gray-400 mt-2">Please allow camera access</p>
    </div>

    <video id="input-video" playsinline></video>
    
    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 8000,
            shapeSize: 18,
            tubeSize: 6,
            responsiveness: 0.15, // Higher = faster, Lower = smoother
            explosionForce: 2.0
        };

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, particles;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let isFist = false;
        let handPos = new THREE.Vector3(0, 0, 0);
        
        // State Machine: 'FORMED', 'COLLAPSING', 'EXPLODING', 'RETURNING'
        let currentMode = 'FORMED'; 
        let explosionStartTime = 0;

        // --- THREE.JS INIT ---
        function initThree() {
            scene = new THREE.Scene();
            // Dark fog for depth
            scene.fog = new THREE.FogExp2(0x050505, 0.003);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 80;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
            document.body.appendChild(renderer.domElement);

            createParticles();
            window.addEventListener('resize', onWindowResize, false);
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const targets = []; // Target positions (The Knot Shape)
            const colors = [];
            const randoms = []; // For noise animation

            // Generate Torus Knot Points
            // We use a mathematical parametric function for a Torus Knot
            const p = 3; // Winding loops
            const q = 4; // Winding loops
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // Determine position on the tube
                const t = (i / CONFIG.particleCount) * Math.PI * 2 * 10; // spread along length
                
                // Torus Knot math
                // Scale factor
                const scale = CONFIG.shapeSize; 
                
                // Base curve
                const r = Math.cos(q * t) + 2;
                let tx = r * Math.cos(p * t);
                let ty = r * Math.sin(p * t);
                let tz = -Math.sin(q * t);

                // Add "thickness" to the knot (tube volume)
                // Random angle around the core wire
                const theta = Math.random() * Math.PI * 2;
                const tubeR = (Math.random() * 0.5 + 0.5) * CONFIG.tubeSize; // Random thickness

                // Approximate normals (simplified for performance) to push out for tube
                // Just adding random noise around the core line for the "cloud" look
                tx = tx * scale + (Math.random()-0.5) * tubeR;
                ty = ty * scale + (Math.random()-0.5) * tubeR;
                tz = tz * scale + (Math.random()-0.5) * tubeR;

                // Store Target
                targets.push(tx, ty, tz);
                
                // Start positions (random spawn)
                positions.push(tx, ty, tz);

                // Colors (Cyan to Purple gradient based on position)
                const color = new THREE.Color();
                const hue = (i / CONFIG.particleCount) * 0.2 + 0.5; // Blue/Purple range
                color.setHSL(hue, 0.8, 0.6);
                colors.push(color.r, color.g, color.b);

                randoms.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.userData = { targets: new Float32Array(targets), randoms: new Float32Array(randoms) };

            const material = new THREE.PointsMaterial({
                size: 0.9,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Smooth Rotation Logic
            // We interpolate current rotation towards target rotation
            const smoothing = 0.05; // Lower = smoother, heavier feel
            particles.rotation.x += (targetRotationX - particles.rotation.x) * smoothing;
            particles.rotation.y += (targetRotationY - particles.rotation.y) * smoothing;

            // 2. Particle Logic based on Mode
            updateParticles();

            renderer.render(scene, camera);
        }

        function updateParticles() {
            const positions = particles.geometry.attributes.position.array;
            const targets = particles.geometry.userData.targets;
            const randoms = particles.geometry.userData.randoms;
            const time = Date.now() * 0.001;

            // Logic switch
            if (isFist && currentMode !== 'EXPLODING') {
                currentMode = 'COLLAPSING';
            } else if (!isFist && currentMode === 'COLLAPSING') {
                currentMode = 'EXPLODING';
                explosionStartTime = Date.now();
            }

            // Status Update
            if (Date.now() - explosionStartTime > 1500 && currentMode === 'EXPLODING') {
                currentMode = 'RETURNING';
            }
            if (currentMode === 'RETURNING') {
                // Check if mostly returned? simplified: just drift back
                // We transition to FORMED visually by the lerp below
                // We can just label it FORMED if we want
            }

            document.getElementById('mode-val').innerText = currentMode;

            // --- PHYSICS KERNEL ---
            // Using a simple loop for speed
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                let px = positions[i3];
                let py = positions[i3 + 1];
                let pz = positions[i3 + 2];

                let tx = targets[i3];
                let ty = targets[i3 + 1];
                let tz = targets[i3 + 2];

                if (currentMode === 'COLLAPSING') {
                    // Suck into hand position
                    // We map handPos (which is -1 to 1) to world coordinates approx
                    const hx = handPos.x * 40;
                    const hy = handPos.y * 30;
                    
                    // Move towards hand center rapidly
                    px += (hx - px) * 0.15;
                    py += (hy - py) * 0.15;
                    pz += (-px * 0.5 - pz) * 0.15; // Swirl effect on Z

                    // Add Vortex Spin
                    const tempX = px;
                    px = px * Math.cos(0.2) - pz * Math.sin(0.2);
                    pz = tempX * Math.sin(0.2) + pz * Math.cos(0.2);
                    
                } 
                else if (currentMode === 'EXPLODING') {
                    // Blast outward from center
                    const dirX = px - (handPos.x * 40);
                    const dirY = py - (handPos.y * 30);
                    const dirZ = pz; // outward z
                    
                    // Normalize approximation
                    const len = Math.sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ) + 0.001;
                    
                    px += (dirX / len) * CONFIG.explosionForce * 2;
                    py += (dirY / len) * CONFIG.explosionForce * 2;
                    pz += (dirZ / len) * CONFIG.explosionForce * 2;

                } 
                else { 
                    // 'RETURNING' or 'FORMED' -> Go to Target Shape
                    // Apply subtle noise
                    const noise = Math.sin(time * 2 + randoms[i] * 10) * 0.2;
                    
                    // Lerp back to shape
                    // We use a variable lerp speed. Fast if far away, slow if close
                    const dist = Math.abs(tx - px) + Math.abs(ty - py) + Math.abs(tz - pz);
                    const speed = dist > 10 ? 0.08 : 0.04;

                    px += (tx - px) * speed + noise;
                    py += (ty - py) * speed + noise;
                    pz += (tz - pz) * speed + noise;
                }

                positions[i3] = px;
                positions[i3 + 1] = py;
                positions[i3 + 2] = pz;
            }

            particles.geometry.attributes.position.needsUpdate = true;
        }


        // --- MEDIAPIPE SETUP (OPTIMIZED FOR LOW LATENCY) ---
        const videoElement = document.getElementById('input-video');
        
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            videoElement.style.display = 'block';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // 1. POSITION (Use wrist and middle finger base for stable center)
                // Invert X for mirror feel
                const x = (1 - landmarks[9].x) * 2 - 1; 
                const y = -(landmarks[9].y * 2 - 1);
                
                // Update global hand pos smoothly
                handPos.lerp(new THREE.Vector3(x, y, 0), 0.3);

                // 2. ROTATION CONTROL (Only if not Fist)
                if (!isFist) {
                    // Map hand screen position to rotation angles
                    // Move hand Left/Right -> Rotate Y
                    // Move hand Up/Down -> Rotate X
                    targetRotationY = x * 2; 
                    targetRotationX = y * 2;
                }

                // 3. GESTURE DETECTION (Fast Euclidian Check)
                const wrist = landmarks[0];
                const tip = landmarks[12]; // Middle finger tip
                const base = landmarks[9]; // Middle finger base
                
                // Distance from tip to wrist
                const openDist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                // Distance from tip to base (knuckle)
                const curlDist = Math.hypot(tip.x - base.x, tip.y - base.y);

                // If tip is very close to base, it's a fist
                // Tweaked threshold for responsiveness
                if (curlDist < 0.1 || openDist < 0.25) {
                    isFist = true;
                } else {
                    isFist = false;
                }
            } else {
                // No hand? Auto-rotate slowly
                targetRotationY += 0.005;
                isFist = false;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        // LOW LATENCY CONFIGURATION
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // 0 = LITE (Fastest), 1 = FULL
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320, // Lower res for faster processing
            height: 240
        });

        // Start Everything
        initThree();
        cameraFeed.start().then(() => {
            animate();
        });

    </script>
</body>
</html>

