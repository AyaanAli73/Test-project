<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hive - Swarm Intelligence</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        
        #ui-layer {
            position: absolute;
            top: 20px; left: 20px;
            pointer-events: none;
            z-index: 10;
            font-family: 'Courier New', Courier, monospace;
        }

        .hud-text {
            color: #00ff88;
            text-shadow: 0 0 5px #00ff88;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            margin-bottom: 2px;
            display: inline-block;
        }

        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff88;
            background: black;
            border: 1px solid #00ff88;
            padding: 20px;
            z-index: 50;
            text-align: center;
        }

        /* Mirror input video */
        #input-video {
            position: absolute;
            bottom: 20px; right: 20px;
            width: 150px; height: 110px;
            transform: scaleX(-1);
            opacity: 0.3;
            z-index: 20;
            border: 1px solid #333;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1 class="text-2xl font-bold text-white mb-4">THE HIVE</h1>
        <div><span class="hud-text">✋ OPEN: ORBIT COMMAND</span></div>
        <div><span class="hud-text">✊ FIST: GRAVITY WELL</span></div>
        <div><span class="hud-text">✌️ VICTORY: TIME FREEZE</span></div>
        <div class="mt-4 text-xs text-gray-400">AGENTS: 2000 | AI: AUTONOMOUS</div>
        <div class="mt-1 text-xs text-yellow-400" id="status">STATUS: SEARCHING...</div>
    </div>

    <div id="loader">
        <div class="animate-pulse font-bold tracking-widest">AWAKENING SWARM...</div>
    </div>

    <video id="input-video" playsinline></video>

    <script>
        // --- CONFIGURATION ---
        const BOID_COUNT = 2000;
        const MAX_SPEED = 1.2;
        const MAX_FORCE = 0.03;
        const NEIGHBOR_DIST = 40;
        
        // --- STATE ---
        const state = {
            handDetected: false,
            handPos: new THREE.Vector3(0,0,0),
            mode: 'IDLE', // IDLE, ORBIT, GRAVITY, FREEZE
            shockwave: 0
        };

        // --- THREE JS ---
        let scene, camera, renderer;
        let mesh; // The InstancedMesh
        const dummy = new THREE.Object3D(); // Helper for matrix calculations

        // Boid Data
        const positions = [];
        const velocities = [];
        const accelerations = [];
        const colors = [];

        function init() {
            scene = new THREE.Scene();
            // Background is black, but we use autoClearColor = false for trails
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 150;

            // Important: preserveDrawingBuffer allows the trail effect
            renderer = new THREE.WebGLRenderer({ antialias: false, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClearColor = false; // Don't clear screen fully
            document.body.appendChild(renderer.domElement);

            // --- GEOMETRY: Tetrahedrons (Look like little ships) ---
            const geometry = new THREE.TetrahedronGeometry(0.8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                wireframe: false
            });

            mesh = new THREE.InstancedMesh(geometry, material, BOID_COUNT);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // We update every frame
            scene.add(mesh);

            // Init Boids
            for (let i = 0; i < BOID_COUNT; i++) {
                // Random position in sphere
                const pos = new THREE.Vector3(
                    (Math.random()-0.5) * 100,
                    (Math.random()-0.5) * 100,
                    (Math.random()-0.5) * 100
                );
                positions.push(pos);
                
                // Random velocity
                const vel = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                velocities.push(vel);
                
                accelerations.push(new THREE.Vector3());

                // Set initial color (Cyber Green/Blue)
                const c = new THREE.Color();
                c.setHSL(0.3 + Math.random()*0.1, 1.0, 0.5);
                mesh.setColorAt(i, c);
            }
            mesh.instanceColor.needsUpdate = true;

            animate();
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- BOID LOGIC ENGINE ---
        function updateBoids() {
            const target = new THREE.Vector3().copy(state.handPos);
            // Map hand pos (-1 to 1) to World Scale
            target.x *= 60;
            target.y *= 45;
            target.z = 0;

            const tempVec = new THREE.Vector3();

            for (let i = 0; i < BOID_COUNT; i++) {
                const pos = positions[i];
                const vel = velocities[i];
                const acc = accelerations[i];

                // 1. BEHAVIOR SELECTION
                if (state.mode === 'FREEZE') {
                    // Do nothing, velocity frozen
                    vel.multiplyScalar(0.9); // Slow to stop
                } 
                else if (state.mode === 'GRAVITY') {
                    // Strong Pull to center (Black Hole)
                    tempVec.subVectors(target, pos);
                    const d = tempVec.length();
                    tempVec.normalize();
                    tempVec.multiplyScalar(1.0); // Strong pull
                    acc.add(tempVec);
                    
                    // Add spiral
                    const spiral = new THREE.Vector3(-tempVec.y, tempVec.x, 0).multiplyScalar(0.5);
                    acc.add(spiral);
                } 
                else if (state.mode === 'ORBIT') {
                    // Orbit Logic
                    tempVec.subVectors(target, pos);
                    const d = tempVec.length();
                    
                    // Pull towards hand
                    if (d > 20) {
                        tempVec.normalize().multiplyScalar(0.05);
                        acc.add(tempVec);
                    }
                    
                    // Rotate around hand (Tangent force)
                    const orbitForce = new THREE.Vector3(-vel.y, vel.x, vel.z).normalize().multiplyScalar(0.05);
                    acc.add(orbitForce);
                    
                    // Noise/Wander
                    if(Math.random() > 0.95) {
                        acc.x += (Math.random()-0.5) * 0.5;
                        acc.y += (Math.random()-0.5) * 0.5;
                        acc.z += (Math.random()-0.5) * 0.5;
                    }
                } 
                else { // IDLE (Shockwave or Wander)
                    if (state.shockwave > 0) {
                        // Explode outward
                        tempVec.subVectors(pos, target).normalize().multiplyScalar(state.shockwave);
                        acc.add(tempVec);
                    } else {
                        // Gentle return to center
                        tempVec.set(0,0,0).sub(pos).normalize().multiplyScalar(0.01);
                        acc.add(tempVec);
                    }
                }

                // 2. PHYSICS UPDATE
                vel.add(acc);
                
                // Speed Limit
                const speed = vel.length();
                if (speed > MAX_SPEED) {
                    vel.normalize().multiplyScalar(MAX_SPEED);
                }
                
                pos.add(vel);
                acc.set(0, 0, 0); // Reset accel

                // 3. VISUAL UPDATE (InstancedMesh)
                dummy.position.copy(pos);
                
                // "Look At" Velocity (The boid faces where it flies)
                // We create a target point slightly ahead
                tempVec.copy(pos).add(vel);
                dummy.lookAt(tempVec);
                dummy.updateMatrix();
                
                mesh.setMatrixAt(i, dummy.matrix);

                // 4. COLOR DYNAMICS
                // High speed = White/Yellow, Low speed = Green/Blue
                const speedRatio = speed / MAX_SPEED;
                const c = new THREE.Color();
                if (state.mode === 'GRAVITY') {
                    // Red/Orange/Purple
                    c.setHSL(0.0 + speedRatio*0.1, 1.0, 0.5); 
                } else {
                    // Cyan/Green
                    c.setHSL(0.4 - speedRatio*0.2, 1.0, 0.5 + speedRatio*0.5);
                }
                mesh.setColorAt(i, c);
            }
            
            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;
            
            // Decay shockwave
            if(state.shockwave > 0) state.shockwave *= 0.9;
        }

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);

            updateBoids();

            // TRAIL EFFECT LOGIC
            // Instead of clearing the screen, we draw a semi-transparent black rectangle
            // This fades previous frames slowly, creating trails
            
            // 1. Render a fading quad manually? No, simpler way in pure ThreeJS without post-process:
            // Use autoClear = false.
            // Every frame, render a full-screen black quad with low opacity.
            
            // Hack for Trails using simple clearing mechanics
            // Just clearing with low opacity doesn't work well in standard WebGLRenderer without accumulation buffer.
            // Alternative: We create a fade plane.
            
            if (!this.fadePlane) {
                const geom = new THREE.PlaneGeometry(10000, 10000);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.15 // Adjust trail length here (Lower = Longer trails)
                });
                this.fadePlane = new THREE.Mesh(geom, mat);
                this.fadePlane.position.z = -100;
                // We don't add to main scene, we render it separately
                this.fadeScene = new THREE.Scene();
                this.fadeScene.add(this.fadePlane);
                this.fadeCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
            }

            // Render Fade Plane (dims previous frame)
            renderer.render(this.fadeScene, this.fadeCam);

            // Render Boids on top
            renderer.render(scene, camera);
        }

        // --- HAND TRACKING ---
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('input-video').style.display = 'block';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                state.handDetected = true;

                // Position
                const x = (1 - lm[9].x) * 2 - 1; 
                const y = -(lm[9].y * 2 - 1);
                state.handPos.lerp(new THREE.Vector3(x, y, 0), 0.2);

                // Gesture
                const wrist = lm[0];
                const tips = [lm[8], lm[12], lm[16], lm[20]];
                let avgDist = 0;
                tips.forEach(t => avgDist += Math.hypot(t.x - wrist.x, t.y - wrist.y));
                avgDist /= 4;

                const isFist = avgDist < 0.22;

                // Victory check
                const isPeace = (lm[8].y < lm[6].y) && (lm[12].y < lm[10].y) && (lm[16].y > lm[14].y);

                // Logic
                const statusEl = document.getElementById('status');
                
                if (isPeace) {
                    state.mode = 'FREEZE';
                    statusEl.innerText = "STATUS: TEMPORAL STASIS";
                    statusEl.className = "text-xs text-blue-400";
                } else if (isFist) {
                    state.mode = 'GRAVITY';
                    statusEl.innerText = "STATUS: GRAVITY WELL DETECTED";
                    statusEl.className = "text-xs text-red-500 font-bold";
                } else {
                    if (state.mode === 'GRAVITY') {
                        // Just released fist
                        state.shockwave = 1.5; // Trigger explosion
                    }
                    state.mode = 'ORBIT';
                    statusEl.innerText = "STATUS: SWARM ORBITING";
                    statusEl.className = "text-xs text-green-400";
                }

            } else {
                state.handDetected = false;
                state.mode = 'IDLE';
                document.getElementById('status').innerText = "STATUS: AWAITING INPUT";
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const video = document.getElementById('input-video');
        const cameraFeed = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 320, height: 240
        });

        init();
        cameraFeed.start();

    </script>
</body>
</html>

