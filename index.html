<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cosmic Energy Core</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
        }

        #c {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* HUD Overlay */
        .hud {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 5;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc;
            text-align: center;
        }

        .energy-bar-container {
            width: 80%; /* Mobile width */
            max-width: 400px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            margin: 10px auto;
            overflow: hidden;
        }

        #energy-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00ffcc, #ff0055);
            transition: width 0.1s linear;
        }

        .status-text {
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* Camera PIP */
        .video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 133px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            background: #000;
            opacity: 0.7;
        }

        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* Loading */
        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffcc;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ffcc;
            text-align: center;
            z-index: 50;
        }
    </style>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <h3>SYSTEM BOOT</h3>
        <p>Initializing Neural Link...</p>
        <small>Please Allow Camera</small>
    </div>

    <div class="hud">
        <div class="hud-top">
            <h2 style="margin:0">COSMIC CORE</h2>
            <div class="energy-bar-container">
                <div id="energy-fill"></div>
            </div>
            <div class="status-text" id="status-text">STABLE</div>
        </div>
    </div>

    <div class="video-container">
        <video id="input_video" playsinline webkit-playsinline></video>
    </div>

    <canvas id="c"></canvas>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP & VISUALS ---
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // Deep space fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // --- The Core (Icosahedron) ---
        const coreGeometry = new THREE.IcosahedronGeometry(1.5, 1);
        
        // Complex material for sci-fi look
        const coreMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x000000, 
            emissive: 0x00ffff,
            emissiveIntensity: 0.5,
            roughness: 0.1,
            metalness: 0.9,
            wireframe: true
        });

        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        
        // Inner glowing solid
        const innerGeo = new THREE.IcosahedronGeometry(1.2, 0);
        const innerMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffcc, 
            transparent: true, 
            opacity: 0.8,
            blending: THREE.AdditiveBlending 
        });
        const innerCore = new THREE.Mesh(innerGeo, innerMat);
        core.add(innerCore);
        scene.add(core);

        // --- Starfield (Warp Effect) ---
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 1000;
        const posArray = new Float32Array(starsCount * 3);
        const velocityArray = new Float32Array(starsCount); // For warp speed

        for(let i=0; i < starsCount * 3; i+=3) {
            posArray[i] = (Math.random() - 0.5) * 40; // x
            posArray[i+1] = (Math.random() - 0.5) * 40; // y
            posArray[i+2] = (Math.random() - 0.5) * 40; // z
            velocityArray[i/3] = Math.random() * 0.1 + 0.05;
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        
        const starsMaterial = new THREE.PointsMaterial({
            size: 0.05,
            color: 0xffffff,
            transparent: true,
            opacity: 0.8
        });

        const starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);

        // Lights
        const light = new THREE.PointLight(0x00ffff, 1, 100);
        light.position.set(0, 0, 0); // Light inside the core
        core.add(light);


        // --- 2. GAME STATE ---
        let state = {
            rotX: 0,
            rotY: 0,
            pinchLevel: 0, // 0 to 1
            energy: 0,
            isOverloading: false
        };

        const uiFill = document.getElementById('energy-fill');
        const uiText = document.getElementById('status-text');


        // --- 3. MEDIAPIPE LOGIC ---
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // Rotation (Hand Center)
                state.rotY = (lm[9].x - 0.5) * 6;
                state.rotX = (lm[9].y - 0.5) * 6;

                // Pinch Detection
                const thumb = lm[4];
                const index = lm[8];
                const dist = Math.hypot(thumb.x - index.x, thumb.y - index.y);

                // Calculate Pinch intensity
                // Dist < 0.05 is full pinch (1.0). Dist > 0.15 is open (0.0).
                let rawPinch = 1 - ((dist - 0.05) * 10); 
                state.pinchLevel = Math.max(0, Math.min(1, rawPinch));
            } else {
                state.pinchLevel = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => 
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // Lite mode for speed
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const videoElement = document.getElementById('input_video');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 480, height: 360, facingMode: 'user'
        });
        cameraUtils.start();


        // --- 4. ANIMATION LOOP (The Fun Part) ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // 1. Update Energy Level based on Pinch
            if (state.pinchLevel > 0.5) {
                state.energy += delta * 2; // Charge up
            } else {
                state.energy -= delta; // Cool down
            }
            state.energy = Math.max(0, Math.min(1, state.energy));

            // 2. UI Updates
            uiFill.style.width = (state.energy * 100) + '%';
            if(state.energy > 0.8) {
                uiText.innerText = "WARNING: CRITICAL";
                uiText.style.color = "#ff0055";
                uiFill.style.background = "#ff0055";
            } else {
                uiText.innerText = "SYSTEM STABLE";
                uiText.style.color = "#00ffcc";
                uiFill.style.background = "linear-gradient(90deg, #00ffcc, #0055ff)";
            }

            // 3. Visual Effects based on Energy
            
            // Color Shift (Blue -> Red)
            const targetColor = new THREE.Color().lerpColors(
                new THREE.Color(0x00ffcc), // Cool
                new THREE.Color(0xff0055), // Hot
                state.energy
            );
            coreMaterial.emissive.copy(targetColor);
            innerMat.color.copy(targetColor);
            light.color.copy(targetColor);

            // Rotation Speed
            // Base rotation + Extra speed from energy
            const speedMultiplier = 1 + (state.energy * 10); 
            
            core.rotation.x += (state.rotX - core.rotation.x) * 0.1;
            core.rotation.y += (state.rotY - core.rotation.y) * 0.1;
            
            // Add chaos rotation if high energy
            core.rotation.z += delta * speedMultiplier;
            innerCore.rotation.y -= delta * speedMultiplier * 2;

            // Scale Pulse
            const pulse = 1 + Math.sin(clock.elapsedTime * (1 + state.energy * 20)) * (0.05 + state.energy * 0.2);
            core.scale.setScalar(pulse);

            // 4. Warp Speed Starfield
            const positions = starField.geometry.attributes.position.array;
            for(let i=0; i<starsCount; i++) {
                // Z movement
                let zIndex = i * 3 + 2;
                // Move stars towards camera. Speed increases with energy.
                positions[zIndex] += (0.1 + state.energy * 2); 

                if(positions[zIndex] > 10) {
                    positions[zIndex] = -30; // Reset to back
                }
            }
            starField.geometry.attributes.position.needsUpdate = true;

            // 5. Camera Shake (The "Impact" feel)
            if(state.energy > 0.5) {
                const shake = (state.energy - 0.5) * 0.2;
                camera.position.x = (Math.random() - 0.5) * shake;
                camera.position.y = (Math.random() - 0.5) * shake;
            } else {
                camera.position.x = 0;
                camera.position.y = 0;
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

