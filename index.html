<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Atomic Spinner (Optimized)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Vision AI -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            touch-action: none;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas { 
            display: block; 
            /* Ensure canvas doesn't stretch via CSS layout */
            width: 100%;
            height: 100%;
        }
        #videoElement { display: none; transform: scaleX(-1); }
        
        /* HUD UI */
        .hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .pill {
            background: rgba(0,0,0,0.7);
            border: 1px solid #333;
            color: #0f0;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            transition: all 0.2s;
        }
        
        .loading {
            position: fixed;
            inset: 0;
            background: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        .preview-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 75px;
            border: 1px solid #333;
            background: #111;
            opacity: 0.5;
            border-radius: 8px;
            overflow: hidden;
        }
        .preview-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader" class="loading">
        <div class="text-4xl font-bold mb-4 animate-pulse">SYSTEM START</div>
        <div class="text-xs text-gray-500">OPTIMIZING GPU...</div>
    </div>

    <!-- Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Hidden Video -->
    <video id="videoElement" playsinline></video>
    
    <!-- Camera Preview -->
    <div class="preview-box">
        <video id="previewVideo" playsinline muted autoplay></video>
    </div>

    <!-- Status HUD -->
    <div class="hud">
        <div id="statusBadge" class="pill border-gray-600 text-gray-500">NO HAND</div>
        <div id="energyBadge" class="pill border-blue-900 text-blue-400">0% CHARGE</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on canvas background
        const videoElement = document.getElementById('videoElement');
        const previewVideo = document.getElementById('previewVideo');
        
        // UI Elements
        const statusBadge = document.getElementById('statusBadge');
        const energyBadge = document.getElementById('energyBadge');
        const loader = document.getElementById('loader');

        // Configuration
        const PARTICLE_COUNT = 400; 
        const RINGS = 3; 
        
        // State
        let width, height;
        let hand = { x: 0, y: 0, active: false, pinching: false };
        let particles = [];
        let globalHue = 0;

        // --- High DPI Scaling ---
        function resize() {
            // Get the device pixel ratio, falling back to 1.
            const dpr = window.devicePixelRatio || 1;
            
            // Get the size of the canvas in CSS pixels.
            const rect = canvas.getBoundingClientRect();
            
            // Give the canvas pixel dimensions of their CSS
            // size * the device pixel ratio.
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            
            // Scale all drawing operations by the dpr, so you
            // don't have to worry about the difference.
            ctx.scale(dpr, dpr);
            
            // Update logic vars
            width = window.innerWidth;
            height = window.innerHeight;
            
            // Reset composite operation after resize as context state might reset
            ctx.globalCompositeOperation = 'lighter';
        }
        window.addEventListener('resize', resize);
        
        // Call resize initially
        setTimeout(resize, 100);

        // --- Particle Class ---
        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.ringIndex = Math.floor(Math.random() * RINGS);
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0.05 + Math.random() * 0.05;
                this.state = 'ORBIT'; 
                
                this.x = 0;
                this.y = 0;
                this.vx = 0;
                this.vy = 0;
                
                // Slightly larger particles for better neon look without blur
                this.size = 2 + Math.random() * 3;
            }

            update(handX, handY, isPinching) {
                if (this.state === 'EXPLODE') {
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    this.vx *= 0.98;
                    this.vy *= 0.98;
                    
                    if (this.x < 0 || this.x > width) {
                        this.vx *= -0.8;
                        this.x = Math.max(0, Math.min(width, this.x));
                    }
                    if (this.y < 0 || this.y > height) {
                        this.vy *= -0.8;
                        this.y = Math.max(0, Math.min(height, this.y));
                    }

                    if (Math.abs(this.vx) < 0.5 && Math.abs(this.vy) < 0.5 && hand.active) {
                        this.state = 'ORBIT';
                    }

                } else {
                    const cx = handX;
                    const cy = handY;

                    const speedMultiplier = isPinching ? 0.3 : 0.05;
                    this.angle += this.speed + speedMultiplier;

                    let targetRadius = isPinching ? 20 : 120;
                    targetRadius += Math.sin(Date.now() / 200) * 10;

                    let ox, oy;
                    
                    if (this.ringIndex === 0) {
                        ox = Math.cos(this.angle) * targetRadius;
                        oy = Math.sin(this.angle) * (targetRadius * 0.3); 
                    } else if (this.ringIndex === 1) {
                        const a = this.angle;
                        const r = targetRadius;
                        const xRaw = Math.cos(a) * r;
                        const yRaw = Math.sin(a) * (r * 0.3);
                        ox = xRaw * 0.5 - yRaw * 0.866;
                        oy = xRaw * 0.866 + yRaw * 0.5;
                    } else {
                        const a = this.angle;
                        const r = targetRadius;
                        const xRaw = Math.cos(a) * r;
                        const yRaw = Math.sin(a) * (r * 0.3);
                        ox = xRaw * 0.5 + yRaw * 0.866;
                        oy = -xRaw * 0.866 + yRaw * 0.5;
                    }

                    this.x = cx + ox;
                    this.y = cy + oy;
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                
                if (this.state === 'EXPLODE') {
                    ctx.fillStyle = '#ffffff'; 
                } else if (hand.pinching) {
                    ctx.fillStyle = '#ff0044'; 
                } else {
                    const ringHue = (globalHue + (this.ringIndex * 120)) % 360;
                    ctx.fillStyle = `hsl(${ringHue}, 100%, 60%)`;
                }
                
                ctx.fill();
            }
            
            explode() {
                this.state = 'EXPLODE';
                const dx = this.x - hand.x;
                const dy = this.y - hand.y;
                const dist = Math.sqrt(dx*dx + dy*dy) || 1; 
                
                const speed = 15 + Math.random() * 25;
                this.vx = (dx / dist) * speed;
                this.vy = (dy / dist) * speed;
            }
        }

        for(let i=0; i<PARTICLE_COUNT; i++) {
            particles.push(new Particle());
        }

        // --- Animation Loop ---
        function animate() {
            // Set Blend Mode to Source-Over to draw the fade rect
            ctx.globalCompositeOperation = 'source-over';
            
            // Clear screen with opacity for trail effect
            // We use fillRect instead of clearRect to create trails
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)'; // Higher opacity = shorter trails, less blurry mess
            ctx.fillRect(0, 0, width, height);

            // Set Blend Mode to Lighter for Neon Glow effect
            // This is the key performance trick. Overlapping circles become brighter.
            ctx.globalCompositeOperation = 'lighter';

            globalHue += 1;

            if (hand.wasPinching && !hand.pinching && hand.active) {
                particles.forEach(p => p.explode());
                // Simple flash
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fillRect(0,0,width,height);
            }
            hand.wasPinching = hand.pinching;

            particles.forEach(p => {
                const tx = hand.active ? hand.x : width/2;
                const ty = hand.active ? hand.y : height/2;
                
                p.update(tx, ty, hand.pinching);
                p.draw(ctx);
            });
            
            // Draw Core
            if (hand.active) {
                const coreSize = hand.pinching ? 15 : 8;
                const shake = hand.pinching ? (Math.random() - 0.5) * 5 : 0;
                
                ctx.beginPath();
                ctx.arc(hand.x + shake, hand.y + shake, coreSize, 0, Math.PI * 2);
                ctx.fillStyle = hand.pinching ? '#ff0000' : '#ffffff';
                ctx.fill();
            }

            requestAnimationFrame(animate);
        }
        animate();


        // --- MediaPipe Hand Tracking ---
        
        function onResults(results) {
            if(loader.style.opacity !== '0') {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const index = landmarks[8];
                const thumb = landmarks[4];

                const targetX = (1 - index.x) * width;
                const targetY = index.y * height;

                hand.x += (targetX - hand.x) * 0.4;
                hand.y += (targetY - hand.y) * 0.4;
                hand.active = true;

                const dx = index.x - thumb.x;
                const dy = index.y - thumb.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                hand.pinching = dist < 0.05;

                statusBadge.textContent = "ATOM ACTIVE";
                statusBadge.style.color = "#0f0";
                statusBadge.style.borderColor = "#0f0";
                statusBadge.style.boxShadow = "0 0 15px rgba(0,255,0,0.3)";

                if (hand.pinching) {
                    energyBadge.textContent = "CRITICAL MASS";
                    energyBadge.style.color = "#fff";
                    energyBadge.style.backgroundColor = "#f00";
                    energyBadge.style.borderColor = "#f00";
                } else {
                    energyBadge.textContent = "STABLE";
                    energyBadge.style.color = "#0ff";
                    energyBadge.style.backgroundColor = "transparent";
                    energyBadge.style.borderColor = "#0ff";
                }

            } else {
                hand.active = false;
                statusBadge.textContent = "NO HAND";
                statusBadge.style.color = "#555";
                statusBadge.style.borderColor = "#333";
                statusBadge.style.boxShadow = "none";
                energyBadge.textContent = "---";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5, // Slightly lower for faster detection
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        videoElement.addEventListener('loadeddata', () => {
            if(videoElement.srcObject) previewVideo.srcObject = videoElement.srcObject;
        });

        camera.start();

    </script>
</body>
</html>


