<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Telekinesis Physics</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        #c { width: 100vw; height: 100vh; display: block; }

        /* Start Screen */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        
        button {
            background: transparent; color: #ff0055; font-size: 24px; font-weight: bold;
            padding: 15px 40px; border: 3px solid #ff0055; border-radius: 8px;
            cursor: pointer; box-shadow: 0 0 20px rgba(255,0,85,0.4);
            text-transform: uppercase; transition: 0.2s;
        }
        button:hover { background: #ff0055; color: white; box-shadow: 0 0 40px rgba(255,0,85,0.8); }

        /* HUD */
        .hud { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; }
        .hud-text { color: white; font-size: 18px; text-shadow: 0 0 10px #ff0055; font-weight: bold; }
        .hud-sub { color: #888; font-size: 12px; margin-top: 5px; }

        /* Camera Box */
        .cam-box {
            position: absolute; bottom: 20px; right: 20px;
            width: 100px; height: 75px; background: #111;
            border: 2px solid #333; border-radius: 8px; opacity: 0; transition: 0.5s;
            overflow: hidden;
        }
        .cam-active { opacity: 0.8; border-color: #ff0055; }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

    </style>

    <!-- Import Map: Three.js + Cannon-es (Physics Engine) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="overlay">
        <h1 style="color:white; margin-bottom: 20px; text-shadow: 0 0 10px #ff0055;">GRAVITY ROOM</h1>
        <button id="btn-start">ACTIVATE PHYSICS</button>
        <p style="color:#aaa; margin-top:15px;">üñê Move to Push &nbsp;&bull;&nbsp; üëå Pinch to Pull</p>
    </div>

    <div class="hud">
        <div class="hud-text" id="status-text">PHYSICS: OFF</div>
        <div class="hud-sub">INTERACTIVE DEMO</div>
    </div>

    <div class="cam-box" id="cam-ui">
        <video id="input_video" playsinline webkit-playsinline></video>
    </div>

    <canvas id="c"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- 1. SCENE & PHYSICS SETUP ---
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101010);
        scene.fog = new THREE.Fog(0x101010, 10, 50);

        // Physics World
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0); // Normal Earth Gravity
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 12);
        camera.lookAt(0, 2, 0);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);
        
        const spotLight = new THREE.SpotLight(0xff0055, 100);
        spotLight.position.set(0, 10, 0);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 1;
        scene.add(spotLight);

        // --- 2. OBJECTS ---
        const meshes = [];
        const bodies = [];

        // Material (Neon physics material)
        const physicsMat = new CANNON.Material('physics');
        const physicsContact = new CANNON.ContactMaterial(physicsMat, physicsMat, {
            friction: 0.3,
            restitution: 0.5 // Bounciness
        });
        world.addContactMaterial(physicsContact);

        // Helper: Create Box
        function createBox(x, y, z, color) {
            const size = 0.8;
            const halfExtents = new CANNON.Vec3(size/2, size/2, size/2);

            // Physics Body
            const body = new CANNON.Body({ mass: 1, material: physicsMat });
            body.addShape(new CANNON.Box(halfExtents));
            body.position.set(x, y, z);
            world.addBody(body);
            bodies.push(body);

            // Visual Mesh
            const geo = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, roughness: 0.1, metalness: 0.5 
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            meshes.push(mesh);
        }

        // Create Floor
        const floorBody = new CANNON.Body({ mass: 0, material: physicsMat }); // Mass 0 = Static
        floorBody.addShape(new CANNON.Plane());
        floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(floorBody);

        const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Create a Stack of Cubes
        const colors = [0x00ffff, 0xff0055, 0xffff00, 0x00ff00];
        for(let i=0; i<4; i++) {
            for(let j=0; j<3; j++) {
                for(let k=0; k<4; k++) {
                    createBox(
                        (i-1.5) + (Math.random()-0.5)*0.1, 
                        j * 1 + 2, 
                        (k-1.5) + (Math.random()-0.5)*0.1, 
                        colors[Math.floor(Math.random()*colors.length)]
                    );
                }
            }
        }

        // --- 3. THE HAND "FORCE FIELD" ---
        // We create a kinematic body (controlled by code, not physics) for the hand
        const handShape = new CANNON.Sphere(1.2);
        const handBody = new CANNON.Body({ mass: 0, material: physicsMat }); // Mass 0 = Static/Kinematic
        handBody.type = CANNON.Body.KINEMATIC; // We will move this manually
        handBody.addShape(handShape);
        handBody.position.set(0, -10, 0); // Hide initially
        world.addBody(handBody);

        // Visual for Hand
        const handMesh = new THREE.Mesh(
            new THREE.SphereGeometry(1.2, 32, 32),
            new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, transparent: true, opacity: 0.3, wireframe: true 
            })
        );
        scene.add(handMesh);

        // Inner core for hand
        const handCore = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        handMesh.add(handCore);


        // --- 4. LOGIC & HAND TRACKING ---
        let state = {
            active: false,
            pinching: false,
            handX: 0, handY: 0,
            depth: 0 // Z-depth estimation
        };

        const statusText = document.getElementById('status-text');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.active = true;
                document.getElementById('cam-ui').classList.add('cam-active');
                
                const lm = results.multiHandLandmarks[0];
                
                // Map screen coordinates (0-1) to 3D world coordinates
                // X: -5 to 5, Y: 0 to 6
                const x = (lm[9].x - 0.5) * -12; // Invert X
                const y = (1.0 - lm[9].y) * 8;
                
                // Z depth estimation based on hand size
                // wrist to middle finger MCP
                const size = Math.hypot(lm[9].x - lm[0].x, lm[9].y - lm[0].y);
                const z = (size - 0.2) * 15; // Rough mapping
                
                // Smooth movement
                state.handX += (x - state.handX) * 0.2;
                state.handY += (y - state.handY) * 0.2;
                state.depth += (z - state.depth) * 0.2;

                // Update Physics Body Position
                handBody.position.set(state.handX, state.handY, Math.max(-2, Math.min(4, state.depth)));

                // Pinch Detection (Thumb + Index)
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                state.pinching = pinchDist < 0.05;

                if (state.pinching) {
                    handMesh.material.color.setHex(0xff0055); // Red
                    statusText.innerText = "MODE: GRAVITY WELL";
                    statusText.style.color = "#ff0055";
                } else {
                    handMesh.material.color.setHex(0x00ffff); // Blue
                    statusText.innerText = "MODE: REPULSOR";
                    statusText.style.color = "#00ffff";
                }

            } else {
                state.active = false;
                handBody.position.set(0, -10, 0); // Move collider away
                statusText.innerText = "SEARCHING...";
                statusText.style.color = "#888";
            }
        }

        async function startSystem() {
            document.getElementById('overlay').style.display = 'none';
            
            const video = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            hands.onResults(onResults);

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 480, height: 360, facingMode: 'user'
            });
            await cameraUtils.start();
        }

        document.getElementById('btn-start').addEventListener('click', startSystem);

        // --- 5. ANIMATION LOOP ---
        const clock = new THREE.Clock();
        const timeStep = 1 / 60;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Step Physics
            world.step(timeStep);

            // Sync Visuals with Physics
            for (let i = 0; i < meshes.length; i++) {
                meshes[i].position.copy(bodies[i].position);
                meshes[i].quaternion.copy(bodies[i].quaternion);
            }

            // Hand Visual Sync
            handMesh.position.copy(handBody.position);
            
            // Hand Rotation (Spin)
            handMesh.rotation.y += 0.05;
            handMesh.rotation.z += 0.02;

            // --- SPECIAL POWERS ---
            if (state.active) {
                if (state.pinching) {
                    // BLACK HOLE LOGIC: Pull all boxes towards hand
                    bodies.forEach(body => {
                        const dx = handBody.position.x - body.position.x;
                        const dy = handBody.position.y - body.position.y;
                        const dz = handBody.position.z - body.position.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        // Force = Direction * Strength
                        if (dist > 1) { // Don't pull if inside
                            const strength = 15 / (dist * dist);
                            body.applyForce(new CANNON.Vec3(dx*strength, dy*strength, dz*strength), body.position);
                            // Zero Gravity effect while pulling
                            body.linearDamping = 0.5;
                        }
                    });
                } else {
                    // REPULSOR LOGIC: Restore Gravity
                    bodies.forEach(body => {
                        body.linearDamping = 0.01; // Normal damping
                    });
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

