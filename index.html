<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Physics Engine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', monospace;
            touch-action: none;
        }

        /* Fullscreen Canvas */
        #c {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Camera Feed (Bottom Right) */
        .video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 133px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            background: #000;
            z-index: 10;
        }

        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* UI Overlay */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
        }

        h1 { margin: 0; font-size: 18px; text-shadow: 0 0 10px cyan; }
        .hint { font-size: 12px; color: #aaa; margin-top: 5px; }

        /* Status Badge */
        #status {
            display: inline-block;
            margin-top: 10px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            background: rgba(0, 255, 255, 0.1);
            color: cyan;
            border: 1px solid rgba(0, 255, 255, 0.3);
            transition: 0.3s;
        }
        
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: cyan;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 20;
            text-align: center;
        }
    </style>

    <!-- Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing Physics...<br>Allow Camera</div>

    <div id="ui">
        <h1>PARTICLE PHYSICS</h1>
        <div class="hint">‚úä HOLD FIST to Gather Sphere</div>
        <div class="hint">üñê RELEASE to Explode</div>
        <div class="hint">üëã MOVE to Rotate</div>
        <div id="status">STATUS: IDLE</div>
    </div>

    <div class="video-container">
        <video id="input_video" playsinline webkit-playsinline></video>
    </div>

    <canvas id="c"></canvas>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP ---
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const scene = new THREE.Scene();
        // Background gradient effect using fog
        scene.fog = new THREE.FogExp2(0x000510, 0.02);
        scene.background = new THREE.Color(0x000510);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // --- 2. PARTICLE SYSTEM ---
        const count = 4000; // Particle Count
        const geometry = new THREE.BufferGeometry();
        
        // Arrays for positions, colors, and our physics data
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        
        // Physics arrays (not passed to GPU, used for calc)
        const velocities = new Float32Array(count * 3);
        const homePositions = new Float32Array(count * 3);

        const color1 = new THREE.Color(0x00ffff); // Cyan (Idle)
        const color2 = new THREE.Color(0xffaa00); // Orange/Gold (Core)

        for(let i = 0; i < count; i++) {
            const i3 = i * 3;
            
            // Generate a random sphere cloud for "Home" positions
            const r = 2.5 + Math.random() * 1.0;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            homePositions[i3] = x;
            homePositions[i3+1] = y;
            homePositions[i3+2] = z;

            // Start at home
            positions[i3] = x;
            positions[i3+1] = y;
            positions[i3+2] = z;

            colors[i3] = color1.r;
            colors[i3+1] = color1.g;
            colors[i3+2] = color1.b;

            velocities[i3] = 0;
            velocities[i3+1] = 0;
            velocities[i3+2] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create a soft glow texture
        const canvasTex = document.createElement('canvas');
        canvasTex.width = 32; canvasTex.height = 32;
        const ctx = canvasTex.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
        const texture = new THREE.Texture(canvasTex);
        texture.needsUpdate = true;

        const material = new THREE.PointsMaterial({
            size: 0.08,
            map: texture,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);


        // --- 3. STATE & PHYSICS LOGIC ---
        let state = {
            isFist: false,
            wasFist: false,
            handX: 0,
            handY: 0
        };

        const statusEl = document.getElementById('status');

        // --- 4. MEDIAPIPE ---
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];

                // Rotation (Center of hand)
                state.handX = (lm[9].x - 0.5) * 4; // Multiplier for sensitivity
                state.handY = (lm[9].y - 0.5) * 4;

                // Fist Detection
                // Compare distance of fingertips to wrist
                const wrist = lm[0];
                const tips = [lm[8], lm[12], lm[16], lm[20]];
                let avgDist = 0;
                tips.forEach(tip => {
                    avgDist += Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                });
                avgDist /= 4;

                // Threshold logic
                if (avgDist < 0.25) {
                    state.isFist = true;
                } else {
                    state.isFist = false;
                }
            }
        }

        const hands = new Hands({locateFile: (file) => 
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const videoElement = document.getElementById('input_video');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 480, height: 360, facingMode: 'user'
        });
        cameraUtils.start();


        // --- 5. PHYSICS LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1); // Cap delta to prevent glitches

            // A. Detect Explosion Trigger (Transition from Fist -> Open)
            let isExploding = false;
            if (state.wasFist && !state.isFist) {
                isExploding = true;
                // UI Flash
                statusEl.innerText = "üí• BOOM!";
                statusEl.style.color = "#ff5555";
                statusEl.style.borderColor = "#ff5555";
                setTimeout(() => {
                    statusEl.innerText = "STATUS: IDLE";
                    statusEl.style.color = "cyan";
                    statusEl.style.borderColor = "cyan";
                }, 1000);
            }
            state.wasFist = state.isFist;

            // B. Visual Status Update
            if (state.isFist) {
                statusEl.innerText = "‚úä GATHERING...";
                statusEl.style.background = "rgba(255, 100, 0, 0.2)";
            } else if (!isExploding && statusEl.innerText.includes("GATHERING")) {
                statusEl.style.background = "rgba(0, 255, 255, 0.1)";
            }

            // C. Update Particles
            const posAttr = particles.geometry.attributes.position;
            const colAttr = particles.geometry.attributes.color;

            // Physics Parameters
            const gatherStrength = 4.0;
            const returnStrength = 1.5;
            const friction = 0.92;
            const explosionForce = 15.0;

            for(let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                let px = posAttr.array[i3];
                let py = posAttr.array[i3+1];
                let pz = posAttr.array[i3+2];

                let vx = velocities[i3];
                let vy = velocities[i3+1];
                let vz = velocities[i3+2];

                // 1. EXPLOSION LOGIC
                if (isExploding) {
                    // Shoot outwards from center
                    // Add some randomness so it looks like debris
                    const dirX = px + (Math.random()-0.5);
                    const dirY = py + (Math.random()-0.5);
                    const dirZ = pz + (Math.random()-0.5);
                    
                    // Normalize vector roughly
                    const len = Math.sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ) || 0.01;
                    
                    vx += (dirX / len) * explosionForce * (0.5 + Math.random());
                    vy += (dirY / len) * explosionForce * (0.5 + Math.random());
                    vz += (dirZ / len) * explosionForce * (0.5 + Math.random());
                }

                // 2. FIST LOGIC (GATHER)
                if (state.isFist) {
                    // Target is Center (0,0,0)
                    // But we want a small sphere, not a single point
                    // So we pull towards 0, but if very close, push out slightly (volume)
                    const distSq = px*px + py*py + pz*pz;
                    const dist = Math.sqrt(distSq);
                    
                    // Pull to center
                    const pull = -dist * gatherStrength * delta;
                    
                    // Normalize direction
                    const nx = px / (dist || 1);
                    const ny = py / (dist || 1);
                    const nz = pz / (dist || 1);

                    vx += nx * pull;
                    vy += ny * pull;
                    vz += nz * pull;

                    // Color: Turn Gold/Red
                    colAttr.array[i3] = THREE.MathUtils.lerp(colAttr.array[i3], color2.r, 0.1);
                    colAttr.array[i3+1] = THREE.MathUtils.lerp(colAttr.array[i3+1], color2.g, 0.1);
                    colAttr.array[i3+2] = THREE.MathUtils.lerp(colAttr.array[i3+2], color2.b, 0.1);

                } else {
                    // 3. OPEN HAND LOGIC (Return to Cloud)
                    // Pull towards "Home Position"
                    const hx = homePositions[i3];
                    const hy = homePositions[i3+1];
                    const hz = homePositions[i3+2];

                    vx += (hx - px) * returnStrength * delta;
                    vy += (hy - py) * returnStrength * delta;
                    vz += (hz - pz) * returnStrength * delta;

                    // Color: Turn Blue
                    colAttr.array[i3] = THREE.MathUtils.lerp(colAttr.array[i3], color1.r, 0.05);
                    colAttr.array[i3+1] = THREE.MathUtils.lerp(colAttr.array[i3+1], color1.g, 0.05);
                    colAttr.array[i3+2] = THREE.MathUtils.lerp(colAttr.array[i3+2], color1.b, 0.05);
                }

                // Apply Friction
                vx *= friction;
                vy *= friction;
                vz *= friction;

                // Update Position
                posAttr.array[i3] += vx * delta;
                posAttr.array[i3+1] += vy * delta;
                posAttr.array[i3+2] += vz * delta;

                // Save Velocity
                velocities[i3] = vx;
                velocities[i3+1] = vy;
                velocities[i3+2] = vz;
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;

            // D. Rotation Control (Based on Hand Position)
            // We rotate the entire container object
            const targetRotX = state.handY; // Hand Y controls Rotation X (Tilt)
            const targetRotY = state.handX; // Hand X controls Rotation Y (Spin)
            
            particles.rotation.x += (targetRotX - particles.rotation.x) * 0.1;
            particles.rotation.y += (targetRotY - particles.rotation.y) * 0.1;

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

