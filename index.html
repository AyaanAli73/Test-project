<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Explosion Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #c { width: 100vw; height: 100vh; display: block; }
        
        /* Camera Feed (Hidden/Small) */
        .video-container {
            position: absolute; bottom: 10px; right: 10px;
            width: 80px; height: 60px; /* Small preview */
            border-radius: 8px; overflow: hidden; opacity: 0.5;
            border: 1px solid #333; z-index: 10;
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* Status UI */
        #status {
            position: absolute; top: 20px; width: 100%;
            text-align: center; color: white;
            font-weight: bold; font-size: 18px;
            text-shadow: 0 0 10px cyan; pointer-events: none;
            z-index: 20;
        }
        #sub-status { font-size: 12px; color: #aaa; margin-top: 5px; }

        #loader {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: cyan; background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 10px;
            text-align: center; font-family: monospace;
            z-index: 30;
        }
    </style>

    <!-- Imports -->
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">Initializing...<br>Please Allow Camera</div>
    
    <div id="status">SPHERE ACTIVE
        <div id="sub-status">MOVES with Hand &bull; FIST to Charge &bull; RELEASE to Explode</div>
    </div>

    <div class="video-container">
        <video id="input_video" playsinline webkit-playsinline></video>
    </div>
    <canvas id="c"></canvas>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP THREE.JS ---
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Mobile optimization

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 6;

        // --- 2. CREATE PARTICLES (PHYSICS BASED) ---
        const particleCount = 3000;
        const geometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(particleCount * 3); // Current Position
        const homes = new Float32Array(particleCount * 3);     // Target Sphere Position
        const velocities = new Float32Array(particleCount * 3);// Movement Speed
        const colors = new Float32Array(particleCount * 3);

        const colorBase = new THREE.Color(0x00ffff); // Cyan
        const colorHot = new THREE.Color(0xff0000);  // Red

        for(let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // Sphere Math
            const r = 2.0; // Radius
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos( (Math.random() * 2) - 1 );

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            // Set Home (Target)
            homes[i3] = x;
            homes[i3+1] = y;
            homes[i3+2] = z;

            // Set Current (Start at home)
            positions[i3] = x;
            positions[i3+1] = y;
            positions[i3+2] = z;

            colors[i3] = colorBase.r;
            colors[i3+1] = colorBase.g;
            colors[i3+2] = colorBase.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create a glow texture manually
        const texCanvas = document.createElement('canvas');
        texCanvas.width = 32; texCanvas.height = 32;
        const ctx = texCanvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
        const texture = new THREE.Texture(texCanvas);
        texture.needsUpdate = true;

        const material = new THREE.PointsMaterial({
            size: 0.12, map: texture,
            vertexColors: true, transparent: true, 
            opacity: 0.8, blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- 3. LOGIC & STATE ---
        let state = {
            isFist: false,
            wasFist: false,
            handX: 0,
            handY: 0
        };

        const statusEl = document.getElementById('status');

        // --- 4. MEDIAPIPE HANDS (IMPROVED ALGORITHM) ---
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];

                // A. Rotation Control (Center of Hand)
                // Normalize and sensitivity
                state.handX = (lm[9].x - 0.5) * 4; 
                state.handY = (lm[9].y - 0.5) * 4;

                // B. ROBUST FIST DETECTION (FIXED)
                // We compare the length of fingers to the size of the palm.
                // This makes it work regardless of how far away your hand is.
                
                const wrist = lm[0];
                const middleKnuckle = lm[9];
                
                // 1. Calculate Palm Size (Reference Scale)
                // Distance from Wrist to Middle Finger Knuckle
                const palmSize = Math.hypot(middleKnuckle.x - wrist.x, middleKnuckle.y - wrist.y);
                
                // 2. Check each finger
                // If tip-to-wrist distance is small (close to palm size), it is curled.
                // If tip-to-wrist distance is large (> 1.6x palm size), it is open.
                const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky
                let curledFingers = 0;
                
                tips.forEach(index => {
                    const tip = lm[index];
                    const distToWrist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                    
                    // Threshold: If tip distance is less than 1.6x palm size, consider it curled
                    if (distToWrist < palmSize * 1.6) {
                        curledFingers++;
                    }
                });

                // 3. To be a "Fist", at least 3 fingers must be curled
                state.isFist = curledFingers >= 3;

            } else {
                // No hand detected? Default to open.
                state.isFist = false;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const video = document.getElementById('input_video');
        const cameraUtils = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 480, height: 360, facingMode: 'user'
        });
        cameraUtils.start();


        // --- 5. ANIMATION LOOP (PHYSICS) ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1); // Limit time step

            // 1. DETECT RELEASE (Fist -> Open)
            let triggerExplosion = false;
            if(state.wasFist && !state.isFist) {
                triggerExplosion = true;
                statusEl.innerText = "üí• BOOM! üí•";
                setTimeout(() => statusEl.innerText = "SPHERE REFORMING...", 1000);
            }
            state.wasFist = state.isFist;

            if(state.isFist) statusEl.innerText = "‚ö†Ô∏è CHARGING...";
            else if(!triggerExplosion && statusEl.innerText.includes("CHARGING")) statusEl.innerText = "SPHERE ACTIVE";

            // 2. ROTATION
            // Smoothly rotate the whole container based on hand position
            points.rotation.y += (state.handX - points.rotation.y) * 0.1;
            points.rotation.x += (state.handY - points.rotation.x) * 0.1;

            // 3. UPDATE PARTICLES
            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;
            
            // Tuning
            const returnForce = 2.0;    // How fast they fly back to sphere
            const dampening = 0.95;     // Friction
            const explosionPower = 15;  // How fast they fly out

            for(let i=0; i < particleCount; i++) {
                const i3 = i*3;

                // --- PHYSICS ---
                if (triggerExplosion) {
                    // EXPLODE: Add massive velocity away from center
                    // Direction = normalized position
                    let len = Math.sqrt(pos[i3]*pos[i3] + pos[i3+1]*pos[i3+1] + pos[i3+2]*pos[i3+2]) || 1;
                    velocities[i3] += (pos[i3]/len) * explosionPower * (0.5 + Math.random());
                    velocities[i3+1] += (pos[i3+1]/len) * explosionPower * (0.5 + Math.random());
                    velocities[i3+2] += (pos[i3+2]/len) * explosionPower * (0.5 + Math.random());
                }

                if (state.isFist) {
                    // CHARGING: Vibrate and turn Red
                    // Add slight jitter
                    pos[i3] += (Math.random()-0.5) * 0.05;
                    pos[i3+1] += (Math.random()-0.5) * 0.05;
                    pos[i3+2] += (Math.random()-0.5) * 0.05;
                    
                    // Lerp to Red
                    col[i3] = THREE.MathUtils.lerp(col[i3], colorHot.r, 0.1);
                    col[i3+1] = THREE.MathUtils.lerp(col[i3+1], colorHot.g, 0.1);
                    col[i3+2] = THREE.MathUtils.lerp(col[i3+2], colorHot.b, 0.1);
                } else {
                    // NORMAL/REFORMING: Pull towards Home
                    // Calculate vector to home
                    const dx = homes[i3] - pos[i3];
                    const dy = homes[i3+1] - pos[i3+1];
                    const dz = homes[i3+2] - pos[i3+2];

                    // Add force to velocity
                    velocities[i3] += dx * returnForce * delta;
                    velocities[i3+1] += dy * returnForce * delta;
                    velocities[i3+2] += dz * returnForce * delta;

                    // Lerp to Cyan
                    col[i3] = THREE.MathUtils.lerp(col[i3], colorBase.r, 0.05);
                    col[i3+1] = THREE.MathUtils.lerp(col[i3+1], colorBase.g, 0.05);
                    col[i3+2] = THREE.MathUtils.lerp(col[i3+2], colorBase.b, 0.05);
                }

                // Apply Velocity to Position
                pos[i3] += velocities[i3] * delta;
                pos[i3+1] += velocities[i3+1] * delta;
                pos[i3+2] += velocities[i3+2] * delta;

                // Apply Friction (Slow down over time)
                velocities[i3] *= dampening;
                velocities[i3+1] *= dampening;
                velocities[i3+2] *= dampening;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();
        
        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>


