<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Hand Controller</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .input_video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.3); /* Golden border */
            z-index: 2;
            transform: scaleX(-1);
            opacity: 0.6;
        }

        #status {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700; /* Gold */
            font-size: 20px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 10;
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 24px;
            border-radius: 50px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
            pointer-events: none;
            transition: all 0.3s ease;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 24px;
            z-index: 20;
            font-family: monospace;
            text-shadow: 0 0 10px #ffd700;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initialising Golden Core...</div>
    <div id="status">Waiting for Hand...</div>
    
    <video class="input_video"></video>
    <div id="canvas-container"></div>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 6000; // Slightly fewer for better performance
        const PARTICLE_SIZE = 0.12;  // Bigger particles for "Shine"
        const SPHERE_RADIUS = 3.5;
        const RING_INNER_RADIUS = 5;
        const RING_OUTER_RADIUS = 9;
        const SCATTER_RADIUS = 30;
        
        // --- COLORS (GOLD THEME) ---
        const COLOR_CORE_GOLD = new THREE.Color(0xffcc00); // Deep Gold
        const COLOR_LIGHT_GOLD = new THREE.Color(0xfff7cc); // Pale Gold
        const COLOR_ORANGE_GOLD = new THREE.Color(0xffaa00); // Fire Gold

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 18;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        // For shine effect, we will vary opacity/size in shader if needed, 
        // but for compatibility we use standard vertex colors.
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 50;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 50;

            // Initialize all as gold
            colors[i * 3] = COLOR_CORE_GOLD.r;
            colors[i * 3 + 1] = COLOR_CORE_GOLD.g;
            colors[i * 3 + 2] = COLOR_CORE_GOLD.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Loading a "Sparkle" texture
        const textureLoader = new THREE.TextureLoader();
        const sprite = textureLoader.load('https://threejs.org/examples/textures/sprites/spark1.png');

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            map: sprite,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending, // Makes them glow when overlapping
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- SHAPE GENERATION ---

        function generateSaturnTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let tx, ty, tz;
                let col;

                if (Math.random() > 0.35) {
                    // SPHERE
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    
                    tx = SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta);
                    ty = SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta);
                    tz = SPHERE_RADIUS * Math.cos(phi);
                    col = COLOR_ORANGE_GOLD; // Darker core
                } else {
                    // RING
                    const angle = Math.random() * Math.PI * 2;
                    const radius = RING_INNER_RADIUS + Math.random() * (RING_OUTER_RADIUS - RING_INNER_RADIUS);
                    
                    tx = Math.cos(angle) * radius;
                    ty = (Math.random() - 0.5) * 0.5; // Thin ring
                    tz = Math.sin(angle) * radius;

                    // Tilt ring
                    const tilt = Math.PI / 5;
                    const yTemp = ty * Math.cos(tilt) - tz * Math.sin(tilt);
                    const zTemp = ty * Math.sin(tilt) + tz * Math.cos(tilt);
                    ty = yTemp;
                    tz = zTemp;

                    col = COLOR_LIGHT_GOLD; // Bright Ring
                }

                targetPositions[i3] = tx;
                targetPositions[i3 + 1] = ty;
                targetPositions[i3 + 2] = tz;

                // Update colors immediately for "Energy" effect
                colors[i3] = col.r;
                colors[i3+1] = col.g;
                colors[i3+2] = col.b;
            }
            geometry.attributes.color.needsUpdate = true;
        }

        function generateScatterTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = Math.random() * SCATTER_RADIUS + 5;

                targetPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                targetPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                targetPositions[i3 + 2] = r * Math.cos(phi);
            }
        }

        // --- INTERACTION VARIABLES ---
        let currentState = 'SCATTER';
        generateScatterTargets();

        // Target rotation/position based on hand
        let targetRotX = 0;
        let targetRotY = 0;
        let targetPosX = 0;
        let targetPosY = 0;

        // --- ANIMATION ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            const positionAttribute = geometry.attributes.position;
            
            // 1. Follow Hand Logic (Lerping for smoothness)
            particles.rotation.x += (targetRotX - particles.rotation.x) * 0.1;
            particles.rotation.y += (targetRotY - particles.rotation.y) * 0.1;
            
            // Move the whole system to follow hand
            particles.position.x += (targetPosX - particles.position.x) * 0.1;
            particles.position.y += (targetPosY - particles.position.y) * 0.1;

            // 2. Particle Movement
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                // Move to shape
                positions[i3]     += (targetPositions[i3] - positions[i3]) * 0.08;
                positions[i3 + 1] += (targetPositions[i3 + 1] - positions[i3 + 1]) * 0.08;
                positions[i3 + 2] += (targetPositions[i3 + 2] - positions[i3 + 2]) * 0.08;

                // Shine/Twinkle effect
                if (currentState === 'SATURN') {
                    // Jitter for energy look
                    if (Math.random() > 0.9) {
                        positions[i3] += (Math.random() - 0.5) * 0.1;
                        positions[i3+1] += (Math.random() - 0.5) * 0.1;
                        positions[i3+2] += (Math.random() - 0.5) * 0.1;
                    }
                } else {
                    // Floating in space
                    positions[i3] += Math.sin(time + positions[i3+1]) * 0.02;
                }
            }
            positionAttribute.needsUpdate = true;

            // Constant slow spin if no hand interaction, or add to hand interaction
            if(currentState === 'SATURN') {
                particles.rotation.y += 0.005; // Always spin a little bit
            }

            renderer.render(scene, camera);
        }

        animate();

        // --- HAND TRACKING LOGIC ---
        const videoElement = document.querySelector('.input_video');
        
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            const statusEl = document.getElementById('status');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // 1. CALCULATE POSITION (Map 0-1 to Screen Coordinates)
                // MediaPipe x is 0(left) to 1(right). 
                // We want: Left Hand -> x = -10, Right Hand -> x = +10
                // We multiply by -1 because webcam is mirrored usually
                const wrist = landmarks[0];
                const x = (0.5 - wrist.x) * 25; // Scale factor 25 covers most of screen width
                const y = (0.5 - wrist.y) * 15; // Scale factor 15 covers height

                targetPosX = x;
                targetPosY = y;
                
                // Rotation based on hand movement extent
                targetRotY = x * 0.1; 
                targetRotX = -y * 0.1;

                // 2. DETECT FIST vs OPEN
                const tips = [8, 12, 16, 20];
                let avgDist = 0;
                tips.forEach(tipIndex => {
                    const tip = landmarks[tipIndex];
                    const d = Math.sqrt(
                        Math.pow(tip.x - wrist.x, 2) + 
                        Math.pow(tip.y - wrist.y, 2)
                    );
                    avgDist += d;
                });
                avgDist = avgDist / tips.length;

                // Threshold logic
                if (avgDist < 0.22) {
                    setShape('SATURN');
                    statusEl.innerText = "LOCKED: GOLDEN CORE";
                    statusEl.style.boxShadow = "0 0 20px rgba(255, 215, 0, 0.6)";
                } else {
                    setShape('SCATTER');
                    statusEl.innerText = "RELEASED";
                    statusEl.style.boxShadow = "none";
                }

            } else {
                // Return to center if no hand
                targetPosX = 0;
                targetPosY = 0;
                targetRotX = 0;
                targetRotY = 0;
                statusEl.innerText = "SHOW HAND TO CONTROL";
            }
        }

        function setShape(shape) {
            if (currentState === shape) return;
            currentState = shape;
            if (shape === 'SATURN') generateSaturnTargets();
            else generateScatterTargets();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraUtils.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

