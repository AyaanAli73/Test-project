<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Particle Galaxy</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            touch-action: none;
        }

        #c {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Heads Up Display */
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 5;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            text-shadow: 0 0 10px #00ffff;
        }

        p {
            margin: 5px 0;
            font-size: 0.8rem;
            color: #aaa;
        }

        .status {
            margin-top: 10px;
            display: inline-block;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.3s;
        }

        /* Camera Feed (Bottom Right) */
        .video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 133px;
            border-radius: 10px;
            border: 1px solid #444;
            overflow: hidden;
            background: #000;
            z-index: 10;
            opacity: 0.7;
        }

        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: cyan;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border: 1px solid cyan;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
        }
    </style>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        Gathering Stardust...<br>
        <small>Please allow camera access</small>
    </div>

    <div class="hud">
        <h1>NEBULA ENGINE</h1>
        <p>üñê Open: Gravity Well</p>
        <p>‚úä Fist: Supernova</p>
        <div id="status-badge" class="status" style="background:#004444; color:#00ffff">SYSTEM STABLE</div>
    </div>

    <div class="video-container">
        <video id="input_video" playsinline webkit-playsinline></video>
    </div>

    <canvas id="c"></canvas>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. GENERATE PARTICLE TEXTURE ---
        // Creating a glow sprite programmatically so we don't need external image files
        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- 2. THREE.JS SETUP ---
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: false }); // Antialias off for performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 4;

        // --- 3. CREATE THE PARTICLES ---
        const particlesCount = 3000; // Number of stars
        const posArray = new Float32Array(particlesCount * 3); // Current positions
        const originalPosArray = new Float32Array(particlesCount * 3); // Target positions (Sphere shape)
        const randomArray = new Float32Array(particlesCount * 3); // Random explosion directions
        const colorsArray = new Float32Array(particlesCount * 3); // Colors

        const color1 = new THREE.Color(0x00ffff); // Blue (Stable)
        const color2 = new THREE.Color(0xff0055); // Red (Explosion)

        for(let i = 0; i < particlesCount; i++) {
            // Spherical Coordinate Math to make a sphere
            const phi = Math.acos( -1 + ( 2 * i ) / particlesCount );
            const theta = Math.sqrt( particlesCount * Math.PI ) * phi;
            
            const r = 1.2; // Radius of sphere

            const x = r * Math.cos( theta ) * Math.sin( phi );
            const y = r * Math.sin( theta ) * Math.sin( phi );
            const z = r * Math.cos( phi );

            // Set Initial positions
            posArray[i*3] = x;
            posArray[i*3+1] = y;
            posArray[i*3+2] = z;

            // Save Original for return
            originalPosArray[i*3] = x;
            originalPosArray[i*3+1] = y;
            originalPosArray[i*3+2] = z;

            // Random Explosion Vector
            randomArray[i*3] = (Math.random() - 0.5) * 6; // Explode X
            randomArray[i*3+1] = (Math.random() - 0.5) * 6; // Explode Y
            randomArray[i*3+2] = (Math.random() - 0.5) * 6; // Explode Z

            // Initial Color (Blue)
            colorsArray[i*3] = color1.r;
            colorsArray[i*3+1] = color1.g;
            colorsArray[i*3+2] = color1.b;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

        const material = new THREE.PointsMaterial({
            size: 0.08,
            map: getTexture(),
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particleMesh = new THREE.Points(geometry, material);
        scene.add(particleMesh);


        // --- 4. GAME LOGIC VARIABLES ---
        let targetRotX = 0;
        let targetRotY = 0;
        let isFist = false;
        let explosionFactor = 0; // 0 = Sphere, 1 = Exploded

        const statusBadge = document.getElementById('status-badge');

        // --- 5. HAND TRACKING ---
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];

                // 1. ROTATION: Track Center of Hand (Index 9)
                targetRotY = (lm[9].x - 0.5) * 5;
                targetRotX = (lm[9].y - 0.5) * 5;

                // 2. FIST DETECTION: 
                // We check the distance between the Wrist (0) and Index Tip (8)
                // If tip is very close to wrist, it's a fist.
                const wrist = lm[0];
                const indexTip = lm[8];
                const pinkyTip = lm[20];
                
                // Average distance of tips to wrist
                const d1 = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
                const d2 = Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y);
                const avgDist = (d1 + d2) / 2;

                // Threshold: If avg distance < 0.25 (depends on hand size/camera distance)
                // usually open hand is > 0.4, fist is < 0.2
                if (avgDist < 0.25) {
                    if(!isFist) {
                        isFist = true;
                        statusBadge.innerText = "‚ö†Ô∏è SUPERNOVA DETECTED";
                        statusBadge.style.background = "#550000";
                        statusBadge.style.color = "#ff5555";
                    }
                } else {
                    if(isFist) {
                        isFist = false;
                        statusBadge.innerText = "SYSTEM STABLE";
                        statusBadge.style.background = "#004444";
                        statusBadge.style.color = "#00ffff";
                    }
                }
            }
        }

        const hands = new Hands({locateFile: (file) => 
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // Lite model
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const videoElement = document.getElementById('input_video');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 480, height: 360, facingMode: 'user'
        });
        cameraUtils.start();


        // --- 6. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // A. Handle Explosion Logic (Smooth Transition)
            const targetExplosion = isFist ? 1 : 0;
            explosionFactor += (targetExplosion - explosionFactor) * 5 * delta;

            // B. Update Every Particle
            const positions = particleMesh.geometry.attributes.position.array;
            const colors = particleMesh.geometry.attributes.color.array;

            for(let i=0; i < particlesCount; i++) {
                const i3 = i*3;

                // Physics: Lerp between Original Sphere Position and Random Explosion Position
                // Current = Original + (RandomVector * ExplosionStrength)
                const px = originalPosArray[i3] + (randomArray[i3] * explosionFactor * 2);
                const py = originalPosArray[i3+1] + (randomArray[i3+1] * explosionFactor * 2);
                const pz = originalPosArray[i3+2] + (randomArray[i3+2] * explosionFactor * 2);

                // Apply movement
                positions[i3] = px;
                positions[i3+1] = py;
                positions[i3+2] = pz;

                // Color Shift: Blue to Red
                // Mix colors based on explosionFactor
                colors[i3] = color1.r + (color2.r - color1.r) * explosionFactor;
                colors[i3+1] = color1.g + (color2.g - color1.g) * explosionFactor;
                colors[i3+2] = color1.b + (color2.b - color1.b) * explosionFactor;
            }

            particleMesh.geometry.attributes.position.needsUpdate = true;
            particleMesh.geometry.attributes.color.needsUpdate = true;

            // C. Global Rotation (Based on hand movement)
            // We add some automatic spin + hand influence
            particleMesh.rotation.x += (targetRotX - particleMesh.rotation.x) * 0.1;
            particleMesh.rotation.y += (targetRotY - particleMesh.rotation.y) * 0.1;
            
            // Subtle idle rotation
            particleMesh.rotation.z += 0.002;

            // D. Camera Shake on Explosion
            if(explosionFactor > 0.1) {
                const shake = explosionFactor * 0.05;
                camera.position.x = (Math.random() - 0.5) * shake;
                camera.position.y = (Math.random() - 0.5) * shake;
            } else {
                camera.position.x = 0;
                camera.position.y = 0;
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

