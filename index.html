<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Gesture Control - 3D Neural Shape</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* Mirror video for natural interaction */
        #input-video { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 160px; 
            height: 120px; 
            z-index: 10; 
            border-radius: 10px; 
            border: 2px solid #333;
            transform: scaleX(-1); 
            display: none;
            opacity: 0.8;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            pointer-events: none;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            padding: 15px;
            border-left: 4px solid #00d2ff;
            border-radius: 4px;
        }

        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            margin-top: 5px;
            background: #222;
            color: #888;
            transition: all 0.2s;
        }

        .active-badge {
            background: #00d2ff;
            color: #000;
            box-shadow: 0 0 10px #00d2ff;
        }

        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00d2ff;
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border: 1px solid #00d2ff;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.2);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-panel">
            <h1 class="text-2xl font-bold text-white mb-2 tracking-wider">NEBULA ENGINE</h1>
            <div class="space-y-2 text-sm text-gray-300">
                <div id="status-fist" class="status-badge">✊ FIST: DRAG</div>
                <div id="status-open" class="status-badge">✋ OPEN: ROTATE</div>
                <div id="status-peace" class="status-badge">✌️ VICTORY: ZOOM IN</div>
                <div id="status-point" class="status-badge">☝️ POINT: ZOOM OUT</div>
            </div>
            <div class="mt-4 text-xs text-gray-500 font-mono">
                LATENCY: <span class="text-green-400">LOW</span> | FPS: 60
            </div>
        </div>
    </div>

    <div id="loader">
        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white mx-auto mb-4"></div>
        <p class="font-bold tracking-widest">SYSTEM INITIALIZING</p>
        <p class="text-xs text-gray-400 mt-2">Accessing Neural Interface (Webcam)...</p>
    </div>

    <video id="input-video" playsinline></video>
    
    <script>
        // --- SETTINGS ---
        const SETTINGS = {
            particleCount: 7000,
            shapeSize: 1.5,
            initialZoom: 65,
            minZoom: 20,
            maxZoom: 120,
            lerpSpeed: 0.08 // Smoothness factor (lower = smoother/slower)
        };

        // --- STATE ---
        const state = {
            mode: 'IDLE', // IDLE, DRAG, ROTATE, ZOOM_IN, ZOOM_OUT
            handPos: { x: 0, y: 0 }, // Normalized -1 to 1
            rotation: { x: 0, y: 0 },
            position: { x: 0, y: 0, z: 0 },
            zoom: SETTINGS.initialZoom
        };

        // --- THREE.JS VARIABLES ---
        let scene, camera, renderer, particleSystem;
        let clock = new THREE.Clock();

        // --- INITIALIZATION ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = state.zoom;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            createNebulaKnot();
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- PARTICLE GENERATION (Complex Knot) ---
        function createNebulaKnot() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            // Torus Knot Parameters (p=3, q=7 creates a complex weave)
            const p = 3;
            const q = 7;
            const tubeRadius = 0.6;
            const mainRadius = 12;

            const color1 = new THREE.Color(0x00d2ff); // Cyan
            const color2 = new THREE.Color(0xff00aa); // Magenta

            for (let i = 0; i < SETTINGS.particleCount; i++) {
                const t = (i / SETTINGS.particleCount) * Math.PI * 2 * 10;
                
                // Curve Path
                const r = Math.cos(q * t) + 2;
                let x = r * Math.cos(p * t);
                let y = r * Math.sin(p * t);
                let z = -Math.sin(q * t);

                // Add volume (tube)
                const theta = Math.random() * Math.PI * 2;
                const rad = (Math.random() * 0.5 + 0.5) * tubeRadius;
                
                // Simplified normals for tube expansion (adding noise)
                x = x * mainRadius + Math.cos(theta) * rad;
                y = y * mainRadius + Math.sin(theta) * rad;
                z = z * mainRadius + (Math.random()-0.5) * rad * 2;

                positions.push(x, y, z);

                // Gradient Color based on angle
                const alpha = (i / SETTINGS.particleCount);
                const color = new THREE.Color().lerpColors(color1, color2, Math.sin(t*0.5)*0.5 + 0.5);
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.35,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. ZOOM LOGIC
            // Smoothly interpolate camera Z
            camera.position.z += (state.zoom - camera.position.z) * SETTINGS.lerpSpeed;

            // 2. ROTATION LOGIC (OPEN HAND)
            // If in ROTATE mode, we update the target rotation based on hand position
            if (state.mode === 'ROTATE') {
                // Map hand X (-1 to 1) to rotation speed or absolute angle?
                // Let's do absolute angle for control
                const targetRotX = state.handPos.y * 1.5;
                const targetRotY = state.handPos.x * 1.5;
                
                particleSystem.rotation.x += (targetRotX - particleSystem.rotation.x) * SETTINGS.lerpSpeed;
                particleSystem.rotation.y += (targetRotY - particleSystem.rotation.y) * SETTINGS.lerpSpeed;
            } else {
                // Idle Spin
                particleSystem.rotation.y += 0.002;
            }

            // 3. POSITION LOGIC (FIST / DRAG)
            if (state.mode === 'DRAG') {
                // Map Hand X/Y to World Position
                // At z=65, the visible frustum is about width ~70
                const targetX = state.handPos.x * 30; 
                const targetY = state.handPos.y * 20;

                particleSystem.position.x += (targetX - particleSystem.position.x) * SETTINGS.lerpSpeed;
                particleSystem.position.y += (targetY - particleSystem.position.y) * SETTINGS.lerpSpeed;
            } else {
                // Return to center slowly if not dragging
                particleSystem.position.x += (0 - particleSystem.position.x) * 0.05;
                particleSystem.position.y += (0 - particleSystem.position.y) * 0.05;
            }

            // 4. ZOOM CONTROLS
            if (state.mode === 'ZOOM_IN') {
                state.zoom = Math.max(state.zoom - 1, SETTINGS.minZoom);
            } else if (state.mode === 'ZOOM_OUT') {
                state.zoom = Math.min(state.zoom + 1, SETTINGS.maxZoom);
            }

            // 5. Visual "Breathing" Pulse
            const positions = particleSystem.geometry.attributes.position.array;
            // Very subtle vertex shake for "electricity" look
            // (Skipping heavy loop for performance, doing scaling instead)
            const scale = 1 + Math.sin(time * 2) * 0.02;
            particleSystem.scale.set(scale, scale, scale);

            renderer.render(scene, camera);
        }


        // --- MEDIAPIPE LOGIC ---
        function updateUI(mode) {
            document.querySelectorAll('.status-badge').forEach(el => el.classList.remove('active-badge'));
            
            if(mode === 'DRAG') document.getElementById('status-fist').classList.add('active-badge');
            if(mode === 'ROTATE') document.getElementById('status-open').classList.add('active-badge');
            if(mode === 'ZOOM_IN') document.getElementById('status-peace').classList.add('active-badge');
            if(mode === 'ZOOM_OUT') document.getElementById('status-point').classList.add('active-badge');
        }

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('input-video').style.display = 'block';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];

                // Update Hand Position (Center of palm approx)
                // Invert X for mirror
                const x = (1 - lm[9].x) * 2 - 1; 
                const y = -(lm[9].y * 2 - 1);
                
                state.handPos.x = x;
                state.handPos.y = y;

                // --- GESTURE RECOGNITION ---
                // Count extended fingers
                const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky
                const pips = [6, 10, 14, 18]; // Lower joints
                
                let extendedCount = 0;
                
                // Thumb Check (special case due to angle)
                // If tip.x is to the right of ip.x (for right hand)... simplified check:
                // Check distance from pinky base (17) to thumb tip (4) vs pinky base to index base (5)
                // Actually, simple X check relative to wrist works okay for broad gestures
                // Let's use a simpler geometry check:
                const thumbTip = lm[4];
                const thumbIp = lm[3];
                const thumbBase = lm[2];
                // Check if thumb tip is far from palm center
                if (Math.hypot(thumbTip.x - lm[9].x, thumbTip.y - lm[9].y) > 0.15) extendedCount++;

                // Fingers Check
                tips.forEach((tipIdx, i) => {
                    // If tip is higher (lower Y value) than pip, it's extended
                    // Note: This simple check assumes hand is upright. 
                    // Better: Distance from wrist
                    const dTip = Math.hypot(lm[tipIdx].x - lm[0].x, lm[tipIdx].y - lm[0].y);
                    const dPip = Math.hypot(lm[pips[i]].x - lm[0].x, lm[pips[i]].y - lm[0].y);
                    if (dTip > dPip) extendedCount++;
                });

                // Specific Logic for gestures
                const isIndexExtended = (Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y) > Math.hypot(lm[6].x - lm[0].x, lm[6].y - lm[0].y));
                const isMiddleExtended = (Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y) > Math.hypot(lm[10].x - lm[0].x, lm[10].y - lm[0].y));
                const isRingExtended = (Math.hypot(lm[16].x - lm[0].x, lm[16].y - lm[0].y) > Math.hypot(lm[14].x - lm[0].x, lm[14].y - lm[0].y));
                const isPinkyExtended = (Math.hypot(lm[20].x - lm[0].x, lm[20].y - lm[0].y) > Math.hypot(lm[18].x - lm[0].x, lm[18].y - lm[0].y));

                // DECIDE MODE
                if (!isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                    // 0 Fingers (Thumb doesn't matter much here) -> FIST
                    state.mode = 'DRAG';
                } 
                else if (isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                    // Only Index -> POINT
                    state.mode = 'ZOOM_OUT';
                }
                else if (isIndexExtended && isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                    // Index + Middle -> PEACE
                    state.mode = 'ZOOM_IN';
                }
                else if (extendedCount >= 4) {
                    // All open -> ROTATE
                    state.mode = 'ROTATE';
                }
                else {
                    state.mode = 'IDLE';
                }

            } else {
                state.mode = 'IDLE';
            }
            
            updateUI(state.mode);
        }

        // --- SETUP CAMERA ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // Lite mode for speed
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const videoElement = document.getElementById('input-video');
        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320, // Low res input for high FPS processing
            height: 240
        });

        // Start
        init();
        cameraFeed.start();

    </script>
</body>
</html>

