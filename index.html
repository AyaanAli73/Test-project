<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Color Flow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            touch-action: none; /* Prevents scrolling on mobile while drawing */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        .toolbar {
            backdrop-filter: blur(10px);
            background-color: rgba(0, 0, 0, 0.6);
            transition: opacity 0.3s ease;
        }
        /* Hide toolbar when interacting if needed, but keeping it visible is usually better */
        
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
    </style>
</head>
<body class="text-white">

    <!-- Canvas Layer -->
    <canvas id="canvas"></canvas>

    <!-- UI Overlay -->
    <div class="fixed top-4 left-4 pointer-events-none select-none opacity-50 text-xs text-gray-400">
        <p>Speed affects thickness â€¢ Drag to draw</p>
    </div>

    <div class="fixed bottom-6 left-1/2 transform -translate-x-1/2 w-[90%] max-w-md p-4 rounded-2xl border border-white/10 toolbar flex flex-col gap-3 shadow-2xl">
        
        <div class="flex justify-between items-center">
            <h1 class="text-sm font-bold tracking-wider text-gray-300 uppercase">3D Brush</h1>
            <div class="flex gap-2">
                <button id="downloadBtn" class="p-2 rounded-full bg-white/10 hover:bg-white/20 transition text-white" title="Save Image">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                        <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                    </svg>
                </button>
                <button id="clearBtn" class="px-4 py-1.5 rounded-full bg-red-500/80 hover:bg-red-500 text-white font-medium text-xs transition shadow-lg shadow-red-500/30">
                    Clear
                </button>
            </div>
        </div>

        <div class="grid grid-cols-2 gap-4">
            <!-- Mode Toggle -->
            <button id="rainbowToggle" class="flex items-center justify-center gap-2 py-2 rounded-lg bg-gradient-to-r from-pink-500 via-purple-500 to-indigo-500 text-xs font-bold shadow-lg transition transform active:scale-95 border border-white/20">
                <span>Rainbow Mode</span>
                <span id="rainbowStatus" class="w-2 h-2 rounded-full bg-white shadow-[0_0_8px_white]"></span>
            </button>
            
            <!-- Color Picker (Hidden if rainbow) -->
            <div class="relative group">
                <input type="color" id="colorPicker" value="#00ffcc" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
                <div class="w-full h-full rounded-lg border border-white/20 flex items-center justify-center gap-2 bg-gray-800 text-xs font-medium group-hover:bg-gray-700 transition">
                    <div id="colorPreview" class="w-3 h-3 rounded-full bg-[#00ffcc] shadow-[0_0_10px_#00ffcc]"></div>
                    <span>Pick Color</span>
                </div>
            </div>
        </div>

        <div class="space-y-1">
            <div class="flex justify-between text-xs text-gray-400">
                <span>Base Size</span>
                <span id="sizeValue">20px</span>
            </div>
            <input type="range" id="sizeSlider" min="5" max="50" value="20" class="w-full">
        </div>

    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on bg
        
        // UI Elements
        const clearBtn = document.getElementById('clearBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const rainbowToggle = document.getElementById('rainbowToggle');
        const rainbowStatus = document.getElementById('rainbowStatus');
        const colorPicker = document.getElementById('colorPicker');
        const colorPreview = document.getElementById('colorPreview');
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');

        // State
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let hue = 0;
        let direction = true;
        let isRainbow = true;
        let baseSize = 20;
        let selectedColor = '#00ffcc';

        // Setup Canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Fill background immediately after resize
            ctx.fillStyle = '#111111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Color Utilities
        function hexToHsl(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            let r = parseInt(result[1], 16);
            let g = parseInt(result[2], 16);
            let b = parseInt(result[3], 16);
            r /= 255, g /= 255, b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max == min) { h = s = 0; } 
            else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        // Drawing Function
        function draw(e) {
            if (!isDrawing) return;

            // Get coordinates (touch or mouse)
            let x, y;
            if (e.touches) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else {
                x = e.clientX;
                y = e.clientY;
            }

            // Calculate distance for interpolation
            const dx = x - lastX;
            const dy = y - lastY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Dynamic size based on speed (faster = thinner)
            // Clamp speed effect to avoid lines disappearing or becoming too huge
            const speedFactor = Math.min(distance, 50); 
            const dynamicSize = Math.max(baseSize - (speedFactor * 0.4), 5);

            // Interpolation: Draw circles between points if moving fast to close gaps
            // This creates the smooth "tube" effect
            const steps = Math.max(Math.abs(dx), Math.abs(dy)); // 1 pixel steps
            
            for (let i = 0; i < steps; i+=2) { // Step by 2 for performance, still looks smooth
                const interpX = lastX + (dx * (i / steps));
                const interpY = lastY + (dy * (i / steps));
                
                // 3D Tube Logic
                // We draw a radial gradient at every point. 
                // Center is light, edge is color. This mimics a sphere. 
                // Stacking spheres creates a tube.
                
                const currentHue = isRainbow ? hue : hexToHsl(selectedColor).h;
                const saturation = isRainbow ? 100 : hexToHsl(selectedColor).s;
                const lightness = isRainbow ? 50 : hexToHsl(selectedColor).l;

                const gradient = ctx.createRadialGradient(
                    interpX, interpY, dynamicSize * 0.1, // Inner circle (highlight)
                    interpX, interpY, dynamicSize        // Outer circle
                );

                // Highlight color (always whitish for 3D specular reflection)
                gradient.addColorStop(0, `hsl(${currentHue}, ${saturation}%, 95%)`); 
                // Mid color
                gradient.addColorStop(0.4, `hsl(${currentHue}, ${saturation}%, ${lightness}%)`);
                // Edge color (darker for depth)
                gradient.addColorStop(1, `hsl(${currentHue}, ${saturation}%, 20%)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(interpX, interpY, dynamicSize, 0, Math.PI * 2);
                ctx.fill();

                if (isRainbow) {
                    hue++; 
                    if (hue >= 360) hue = 0;
                }
            }

            lastX = x;
            lastY = y;
        }

        // Event Listeners
        const startDraw = (e) => {
            isDrawing = true;
            if (e.touches) {
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else {
                lastX = e.clientX;
                lastY = e.clientY;
            }
            // Draw a single dot if clicked
            draw(e); 
        };

        const stopDraw = () => {
            isDrawing = false;
            ctx.beginPath(); // Reset path
        };

        // Mouse
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDraw);
        canvas.addEventListener('mouseout', stopDraw);

        // Touch
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Stop scrolling
            startDraw(e);
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Stop scrolling
            draw(e);
        }, { passive: false });
        
        canvas.addEventListener('touchend', stopDraw);

        // UI Logic
        clearBtn.addEventListener('click', () => {
            // Fade out effect
            ctx.fillStyle = 'rgba(17, 17, 17, 0.1)';
            let fadeCount = 0;
            const fade = setInterval(() => {
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                fadeCount++;
                if(fadeCount > 10) {
                    clearInterval(fade);
                    ctx.fillStyle = '#111111';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }, 20);
        });

        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'my-3d-drawing.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        rainbowToggle.addEventListener('click', () => {
            isRainbow = !isRainbow;
            if (isRainbow) {
                rainbowToggle.classList.add('ring-2', 'ring-offset-2', 'ring-offset-gray-900', 'ring-purple-500');
                rainbowStatus.style.backgroundColor = 'white';
                rainbowStatus.style.boxShadow = '0 0 8px white';
            } else {
                rainbowToggle.classList.remove('ring-2', 'ring-offset-2', 'ring-offset-gray-900', 'ring-purple-500');
                rainbowStatus.style.backgroundColor = 'transparent';
                rainbowStatus.style.boxShadow = 'none';
            }
        });

        colorPicker.addEventListener('input', (e) => {
            selectedColor = e.target.value;
            colorPreview.style.backgroundColor = selectedColor;
            colorPreview.style.boxShadow = `0 0 10px ${selectedColor}`;
            // If user picks a color, turn off rainbow automatically
            if(isRainbow) rainbowToggle.click(); 
        });

        sizeSlider.addEventListener('input', (e) => {
            baseSize = parseInt(e.target.value);
            sizeValue.textContent = baseSize + 'px';
        });

        // Initial setup for rainbow button state
        rainbowToggle.classList.add('ring-2', 'ring-offset-2', 'ring-offset-gray-900', 'ring-purple-500');

    </script>
</body>
</html>

